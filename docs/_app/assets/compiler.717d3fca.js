(function(){"use strict";var commonjsGlobal=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function getAugmentedNamespace(a){if(a.__esModule)return a;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(a).forEach(function(r){var t=Object.getOwnPropertyDescriptor(a,r);Object.defineProperty(e,r,t.get?t:{enumerable:!0,get:function(){return a[r]}})}),e}var build={},compiler={},importResolver={},__viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze({__proto__:null,default:__viteBrowserExternal}),require$$1$1=getAugmentedNamespace(__viteBrowserExternal$1);Object.defineProperty(importResolver,"__esModule",{value:!0}),importResolver.FileSystemResolver=void 0;class FileSystemResolver{constructor(e){const{readFileSync:r}=require$$1$1,{resolve:t,dirname:n}=require$$1$1;this.resolve=t,this.readFile=r,this.baseDir=e?n(e):process==null?void 0:process.cwd()}path(e){return this.resolve(this.baseDir,e)}body(e){return this.readFile(e,"utf-8")}}importResolver.FileSystemResolver=FileSystemResolver;var grammarBuilder={},interpreter={},parser$1={},column$1={},state$1={};Object.defineProperty(state$1,"__esModule",{value:!0}),state$1.State=void 0;const parser_1$4=parser$1;class State$1{constructor(e,r,t,n){this.rule=e,this.dot=r,this.reference=t,this.wantedBy=n,this.data=[],this.isComplete=this.dot===e.symbols.length}nextState(e){const r=new State$1(this.rule,this.dot+1,this.reference,this.wantedBy);return r.left=this,r.right=e,r.isComplete&&(r.data=r.build(),r.right=void 0),r}build(){const e=[];let r=this;do e.push(r.right.data),r=r.left;while(r.left);return e.reverse(),e}finish(){this.rule.transform?this.data=this.rule.transform({data:this.data,reference:this.reference,dot:this.dot,name:this.rule.name,reject:parser_1$4.NearleyParser.fail}):this.rule.postprocess&&(this.data=this.rule.postprocess(this.data,this.reference,parser_1$4.NearleyParser.fail))}}state$1.State=State$1,Object.defineProperty(column$1,"__esModule",{value:!0}),column$1.Column=void 0;const parser_1$3=parser$1,state_1$1=state$1;class Column$1{constructor(e,r){this.ruleMap=e,this.index=r,this.states=[],this.wants=Object.create(null),this.scannable=[],this.completed=Object.create(null)}process(e){let r=0,t;for(;t=this.states[r++];)if(t.isComplete){if(t.finish(),t.data!==parser_1$3.NearleyParser.fail){const{wantedBy:n}=t;for(let o=n.length;o--;)this.complete(n[o],t);if(t.reference===this.index){const{name:o}=t.rule;this.completed[o]=this.completed[o]||[],this.completed[o].push(t)}}}else{const n=t.rule.symbols[t.dot];if(typeof n!="string"){this.scannable.push(t);continue}if(this.wants[n]){if(this.wants[n].push(t),this.completed[n])for(const o of this.completed[n])this.complete(t,o)}else this.wants[n]=[t],this.predict(n)}}predict(e){if(!!this.ruleMap[e])for(const r of this.ruleMap[e])this.states.push(new state_1$1.State(r,0,this.index,this.wants[e]))}complete(e,r){const t=e.nextState(r);this.states.push(t)}}column$1.Column=Column$1;var lexer={};Object.defineProperty(lexer,"__esModule",{value:!0}),lexer.StreamLexer=void 0;class StreamLexer{constructor(){this.index=0,this.buffer="",this.line=1,this.lastLineBreak=0}reset(e,r){this.buffer=e,this.index=0,this.line=r?r.line:1,this.lastLineBreak=r?-r.col:0}next(){if(this.index<this.buffer.length){const e=this.buffer[this.index++];return e===`
`&&(this.line++,this.lastLineBreak=this.index),{value:e}}}save(){return{line:this.line,col:this.index-this.lastLineBreak}}formatError(e,r){var t=this.buffer;if(typeof t=="string"){var n=t.split(`
`).slice(Math.max(0,this.line-5),this.line);t.indexOf(`
`,this.index);var o=this.index-this.lastLineBreak,l=String(this.line).length;return r+=" at line "+this.line+" col "+o+`:

`,r+=n.map(function(h,s){return c(this.line-n.length+s+1,l)+" "+h},this).join(`
`),r+=`
`+c("",l+o)+`^
`,r}else return r+" at index "+(this.index-1);function c(h,s){var $=String(h);return Array(s-$.length+1).join(" ")+$}}}lexer.StreamLexer=StreamLexer;var errorReporting$1={};Object.defineProperty(errorReporting$1,"__esModule",{value:!0}),errorReporting$1.ParserErrorService=void 0;class ParserErrorService$1{constructor(e){this.parser=e}lexerError(e){let r,t;const n=e.token;return n?(r="input "+JSON.stringify(n.text[0])+" (lexer error)",t=this.parser.lexer.formatError(n,"Syntax error")):(r="input (lexer error)",t=e.message),this.reportErrorCommon(t,r)}tokenError(e){const r=(e.type?e.type+" token: ":"")+JSON.stringify(e.value!==void 0?e.value:e),t=this.parser.lexer.formatError(e,"Syntax error"),n=new Error(this.reportErrorCommon(t,r));return n.offset=this.parser.current,n.token=e,n}displayStateStack(e,r){let t,n=0;for(let o=0;o<e.length;o++){const l=e[o],c=this.formatRule(l.rule,l.dot);c===t?n++:(n>0&&r.push("    ^ "+n+" more lines identical to this"),n=0,r.push("    "+c)),t=c}}reportErrorCommon(e,r){const t=[];t.push(e);const n=this.parser.table.length-2,o=this.parser.table[n],l=o.states.filter(c=>{const h=c.rule.symbols[c.dot];return h&&typeof h!="string"});return l.length===0?(t.push("Unexpected "+r+`. I did not expect any more input. Here is the state of my parse table:
`),this.displayStateStack(o.states,t)):(t.push("Unexpected "+r+`. Instead, I was expecting to see one of the following:
`),l.map(h=>this.buildFirstStateStack(h,new Set)||[h]).forEach(h=>{const s=h[0],$=s.rule.symbols[s.dot],y=this.getSymbolDisplay($);t.push("A "+y+" based on:"),this.displayStateStack(h,t)})),t.push(""),t.join(`
`)}getSymbolDisplay(e){const r=typeof e;if(r==="string")return e;if(r==="object"){if(e.literal)return JSON.stringify(e.literal);if(e instanceof RegExp)return"character matching "+e;if(e.type)return e.type+" token";if(e.test)return"token matching "+String(e.test);throw new Error("Unknown symbol type: "+JSON.stringify(e))}}buildFirstStateStack(e,r){if(r.has(e))return null;if(e.wantedBy.length===0)return[e];const t=e.wantedBy[0],n=new Set(r);n.add(e);const o=this.buildFirstStateStack(t,n);return o===null?null:[e].concat(o)}formatRule(e,r){let t=e.symbols.slice(0,r).map(this.getSymbolShortDisplay).join(" ");return typeof r!="undefined"&&(t+=" \u25CF "+e.symbols.slice(r).map(this.getSymbolShortDisplay).join(" ")),e.name+" \u2192 "+t}getSymbolShortDisplay(e){if(typeof e=="string")return e;if("literal"in e)return JSON.stringify(e.literal);if(e instanceof RegExp)return e.toString();if("type"in e)return"%"+e.type;if("test"in e)return"<"+String(e.test)+">";throw new Error("Unknown symbol type: "+e)}}errorReporting$1.ParserErrorService=ParserErrorService$1,Object.defineProperty(parser$1,"__esModule",{value:!0}),parser$1.NearleyParser=void 0;const column_1$1=column$1,lexer_1$1=lexer,error_reporting_1$1=errorReporting$1;class NearleyParser{constructor({rules:e,start:r,lexer:t,map:n},o={}){if(this.keepHistory=!1,this.current=0,this.ruleMap=Object.create(null),this.rules=e,this.start=r||this.rules[0].name,this.lexer=t,!n)for(const c of e)this.ruleMap[c.name]?this.ruleMap[c.name].push(c):this.ruleMap[c.name]=[c];this.keepHistory=!!(o!=null&&o.keepHistory),this.errorService=new error_reporting_1$1.ParserErrorService(this),this.lexer=(o==null?void 0:o.lexer)||this.lexer||new lexer_1$1.StreamLexer;const l=new column_1$1.Column(this.ruleMap,0);this.table=[l],l.wants[this.start]=[],l.predict(this.start),l.process()}next(){try{return this.lexer.next()}catch(e){const r=new column_1$1.Column(this.ruleMap,this.current+1);throw this.table.push(r),this.errorService.lexerError(e)}}feed(e){this.lexer.reset(e,this.lexerState);let r,t;for(;r=this.next();){t=this.table[this.current],this.keepHistory||delete this.table[this.current-1];const n=this.current+1,o=new column_1$1.Column(this.ruleMap,n);this.table.push(o);const l=r.text!==void 0?r.text:r.value,c=this.lexer.constructor===lexer_1$1.StreamLexer?r.value:r,{scannable:h}=t;for(let s=h.length;s--;){const $=h[s],y=$.rule.symbols[$.dot];if(y.test&&y.test(c)||y.type&&y.type===r.type||(y==null?void 0:y.literal)===l){const k=$.nextState({data:c,token:r,isToken:!0,reference:n-1});o.states.push(k)}}if(o.process(),o.states.length===0)throw this.errorService.tokenError(r);this.keepHistory&&(t.lexerState=this.lexer.save()),this.current++}t&&(this.lexerState=this.lexer.save()),this.results=this.finish()}save(){const e=this.table[this.current];return e.lexerState=this.lexerState,e}restore(e){const r=e.index;this.current=r,this.table[r]=e,this.table.splice(r+1),this.lexerState=e.lexerState,this.results=this.finish()}rewind(e){if(!this.keepHistory)throw new Error("set option `keepHistory` to enable rewinding");this.restore(this.table[e])}finish(){const e=[],{states:r}=this.table[this.table.length-1];for(const{rule:{name:t,symbols:n},dot:o,reference:l,data:c}of r)t===this.start&&o===n.length&&!l&&c!==NearleyParser.fail&&e.push(c);return e}}parser$1.NearleyParser=NearleyParser,NearleyParser.fail=Symbol();var parser={},column={},state={};Object.defineProperty(state,"__esModule",{value:!0}),state.State=void 0;const parser_1$2=parser;class State{constructor(e,r,t,n){this.rule=e,this.dot=r,this.reference=t,this.wantedBy=n,this.data=[],this.isComplete=this.dot===e.symbols.length}nextState(e){const r=new State(this.rule,this.dot+1,this.reference,this.wantedBy);return r.left=this,r.right=e,r.isComplete&&(r.data=r.build(),r.right=void 0),r}build(){const e=[];let r=this;do e.push(r.right.data),r=r.left;while(r.left);return e.reverse(),e}finish(){this.rule.transform?this.data=this.rule.transform({data:this.data,reference:this.reference,dot:this.dot,name:this.rule.name,reject:parser_1$2.EarleyParser.fail}):this.rule.postprocess&&(this.data=this.rule.postprocess(this.data,this.reference,parser_1$2.EarleyParser.fail))}}state.State=State,Object.defineProperty(column,"__esModule",{value:!0}),column.Column=void 0;const parser_1$1=parser,state_1=state;class Column{constructor(e,r){this.ruleMap=e,this.index=r,this.states=[],this.wants=Object.create(null),this.scannable=[],this.completed=Object.create(null)}process(e){let r=0,t;for(;t=this.states[r++];)if(t.isComplete){if(t.finish(),t.data!==parser_1$1.EarleyParser.fail){const{wantedBy:n}=t;for(let o=n.length;o--;)this.complete(n[o],t);if(t.reference===this.index){const{name:o}=t.rule;this.completed[o]=this.completed[o]||[],this.completed[o].push(t)}}}else{const n=t.rule.symbols[t.dot];if(typeof n!="string"){this.scannable.push(t);continue}if(this.wants[n]){if(this.wants[n].push(t),this.completed[n])for(const o of this.completed[n])this.complete(t,o)}else this.wants[n]=[t],this.predict(n)}}predict(e){if(!!this.ruleMap[e])for(const r of this.ruleMap[e])this.states.push(new state_1.State(r,0,this.index,this.wants[e]))}complete(e,r){const t=e.nextState(r);this.states.push(t)}}column.Column=Column;var errorReporting={};Object.defineProperty(errorReporting,"__esModule",{value:!0}),errorReporting.ParserErrorService=void 0;class ParserErrorService{constructor(e){this.parser=e}lexerError(e){let r,t;const n=e.token;return n?(r="input "+JSON.stringify(n.text[0])+" (lexer error)",t=this.parser.lexer.formatError(n,"Syntax error")):(r="input (lexer error)",t=e.message),this.reportErrorCommon(t,r)}tokenError(e){const r=(e.type?e.type+" token: ":"")+JSON.stringify(e.value!==void 0?e.value:e),t=this.parser.lexer.formatError(e,"Syntax error"),n=new Error(this.reportErrorCommon(t,r));return n.offset=this.parser.current,n.token=e,n}displayStateStack(e,r){let t,n=0;for(let o=0;o<e.length;o++){const l=e[o],c=this.formatRule(l.rule,l.dot);c===t?n++:(n>0&&r.push("    ^ "+n+" more lines identical to this"),n=0,r.push("    "+c)),t=c}}reportErrorCommon(e,r){const t=[];t.push(e);const n=this.parser.table.length-2,o=this.parser.table[n],l=o.states.filter(c=>{const h=c.rule.symbols[c.dot];return h&&typeof h!="string"});return l.length===0?(t.push("Unexpected "+r+`. I did not expect any more input. Here is the state of my parse table:
`),this.displayStateStack(o.states,t)):(t.push("Unexpected "+r+`. Instead, I was expecting to see one of the following:
`),l.map(h=>this.buildFirstStateStack(h,new Set)||[h]).forEach(h=>{const s=h[0],$=s.rule.symbols[s.dot],y=this.getSymbolDisplay($);t.push("A "+y+" based on:"),this.displayStateStack(h,t)})),t.push(""),t.join(`
`)}getSymbolDisplay(e){const r=typeof e;if(r==="string")return e;if(r==="object"){if(e.literal)return JSON.stringify(e.literal);if(e instanceof RegExp)return"character matching "+e;if(e.type)return e.type+" token";if(e.test)return"token matching "+String(e.test);throw new Error("Unknown symbol type: "+JSON.stringify(e))}}buildFirstStateStack(e,r){if(r.has(e))return null;if(e.wantedBy.length===0)return[e];const t=e.wantedBy[0],n=new Set(r);n.add(e);const o=this.buildFirstStateStack(t,n);return o===null?null:[e].concat(o)}formatRule(e,r){let t=e.symbols.slice(0,r).map(this.getSymbolShortDisplay).join(" ");return typeof r!="undefined"&&(t+=" \u25CF "+e.symbols.slice(r).map(this.getSymbolShortDisplay).join(" ")),e.name+" \u2192 "+t}getSymbolShortDisplay(e){if(typeof e=="string")return e;if("literal"in e)return JSON.stringify(e.literal);if(e instanceof RegExp)return e.toString();if("type"in e)return"%"+e.type;if("test"in e)return"<"+String(e.test)+">";throw new Error("Unknown symbol type: "+e)}}errorReporting.ParserErrorService=ParserErrorService,Object.defineProperty(parser,"__esModule",{value:!0}),parser.EarleyParser=void 0;const column_1=column,lexer_1=lexer,error_reporting_1=errorReporting;class EarleyParser{constructor({rules:e,start:r,lexer:t,map:n},o={}){if(this.keepHistory=!1,this.current=0,this.ruleMap=Object.create(null),this.rules=e,this.start=r||this.rules[0].name,this.lexer=t,!n)for(const c of e)this.ruleMap[c.name]?this.ruleMap[c.name].push(c):this.ruleMap[c.name]=[c];this.keepHistory=!!(o!=null&&o.keepHistory),this.errorService=new error_reporting_1.ParserErrorService(this),this.lexer=(o==null?void 0:o.lexer)||this.lexer||new lexer_1.StreamLexer;const l=new column_1.Column(this.ruleMap,0);this.table=[l],l.wants[this.start]=[],l.predict(this.start),l.process()}next(){try{return this.lexer.next()}catch(e){const r=new column_1.Column(this.ruleMap,this.current+1);throw this.table.push(r),this.errorService.lexerError(e)}}feed(e){this.lexer.reset(e,this.lexerState);let r,t;for(;r=this.next();){t=this.table[this.current],this.keepHistory||delete this.table[this.current-1];const n=this.current+1,o=new column_1.Column(this.ruleMap,n);this.table.push(o);const l=r.text!==void 0?r.text:r.value,c=this.lexer.constructor===lexer_1.StreamLexer?r.value:r,{scannable:h}=t;for(let s=h.length;s--;){const $=h[s],y=$.rule.symbols[$.dot];if(y.test&&y.test(c)||y.type&&y.type===r.type||(y==null?void 0:y.literal)===l){const k=$.nextState({data:c,token:r,isToken:!0,reference:n-1});o.states.push(k)}}if(o.process(),o.states.length===0)throw this.errorService.tokenError(r);this.keepHistory&&(t.lexerState=this.lexer.save()),this.current++}t&&(this.lexerState=this.lexer.save()),this.results=this.finish()}save(){const e=this.table[this.current];return e.lexerState=this.lexerState,e}restore(e){const r=e.index;this.current=r,this.table[r]=e,this.table.splice(r+1),this.lexerState=e.lexerState,this.results=this.finish()}rewind(e){if(!this.keepHistory)throw new Error("set option `keepHistory` to enable rewinding");this.restore(this.table[e])}finish(){const e=[],{states:r}=this.table[this.table.length-1];for(const{rule:{name:t,symbols:n},dot:o,reference:l,data:c}of r)t===this.start&&o===n.length&&!l&&c!==EarleyParser.fail&&e.push(c);return e}}parser.EarleyParser=EarleyParser,EarleyParser.fail=Symbol(),Object.defineProperty(interpreter,"__esModule",{value:!0}),interpreter.Interpreter=void 0;const parser_1=parser$1,parser_2=parser,ParserRegistry={nearley:parser_1.NearleyParser,earley:parser_2.EarleyParser};class Interpreter{constructor(e,r={parser:"nearley"}){this.grammar=e,this.options=r,this.parserClass=ParserRegistry[r.parser],this.parser=new this.parserClass(this.grammar,r)}get results(){return this.parser.results}feed(e){return this.parser.feed(e),this.results}run(e){const r=new this.parserClass(this.grammar,this.options);return r.feed(e),r.results[0]}}interpreter.Interpreter=Interpreter;const grammar$5={rules:[{name:"cow$string$1",symbols:[{literal:"M"},{literal:"O"}],postprocess:{builtin:"joiner"}},{name:"cow$ebnf$1",symbols:[{literal:"O"}]},{name:"cow$ebnf$1",symbols:["cow$ebnf$1",{literal:"O"}],postprocess:{builtin:"arrpush"}},{name:"cow",symbols:["cow$string$1","cow$ebnf$1"]}],body:[],customTokens:[],config:{},macros:{},start:"cow",version:"unknown"},exportName$5="grammar";var require$$1={grammar:grammar$5,exportName:exportName$5};const grammar$4={rules:[{name:"unsigned_int$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"unsigned_int$ebnf$1",symbols:["unsigned_int$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"unsigned_int",symbols:["unsigned_int$ebnf$1"],postprocess:`
    function(d) {
        return parseInt(d[0].join(""));
    }
`},{name:"int$ebnf$1$subexpression$1",symbols:[{literal:"-"}]},{name:"int$ebnf$1$subexpression$1",symbols:[{literal:"+"}]},{name:"int$ebnf$1",symbols:["int$ebnf$1$subexpression$1"],postprocess:{builtin:"id"}},{name:"int$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"int$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"int$ebnf$2",symbols:["int$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"int",symbols:["int$ebnf$1","int$ebnf$2"],postprocess:`
    function(d) {
        if (d[0]) {
            return parseInt(d[0][0]+d[1].join(""));
        } else {
            return parseInt(d[1].join(""));
        }
    }
`},{name:"unsigned_decimal$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"unsigned_decimal$ebnf$1",symbols:["unsigned_decimal$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",symbols:["unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"unsigned_decimal$ebnf$2$subexpression$1",symbols:[{literal:"."},"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1"]},{name:"unsigned_decimal$ebnf$2",symbols:["unsigned_decimal$ebnf$2$subexpression$1"],postprocess:{builtin:"id"}},{name:"unsigned_decimal$ebnf$2",symbols:[],postprocess:{builtin:"nuller"}},{name:"unsigned_decimal",symbols:["unsigned_decimal$ebnf$1","unsigned_decimal$ebnf$2"],postprocess:`
    function(d) {
        return parseFloat(
            d[0].join("") +
            (d[1] ? "."+d[1][1].join("") : "")
        );
    }
`},{name:"decimal$ebnf$1",symbols:[{literal:"-"}],postprocess:{builtin:"id"}},{name:"decimal$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"decimal$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"decimal$ebnf$2",symbols:["decimal$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"decimal$ebnf$3$subexpression$1$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"decimal$ebnf$3$subexpression$1$ebnf$1",symbols:["decimal$ebnf$3$subexpression$1$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"decimal$ebnf$3$subexpression$1",symbols:[{literal:"."},"decimal$ebnf$3$subexpression$1$ebnf$1"]},{name:"decimal$ebnf$3",symbols:["decimal$ebnf$3$subexpression$1"],postprocess:{builtin:"id"}},{name:"decimal$ebnf$3",symbols:[],postprocess:{builtin:"nuller"}},{name:"decimal",symbols:["decimal$ebnf$1","decimal$ebnf$2","decimal$ebnf$3"],postprocess:`
    function(d) {
        return parseFloat(
            (d[0] || "") +
            d[1].join("") +
            (d[2] ? "."+d[2][1].join("") : "")
        );
    }
`},{name:"percentage",symbols:["decimal",{literal:"%"}],postprocess:`
    function(d) {
        return d[0]/100;
    }
`},{name:"jsonfloat$ebnf$1",symbols:[{literal:"-"}],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"jsonfloat$ebnf$2",symbols:["jsonfloat$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"jsonfloat$ebnf$3$subexpression$1$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"jsonfloat$ebnf$3$subexpression$1$ebnf$1",symbols:["jsonfloat$ebnf$3$subexpression$1$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"jsonfloat$ebnf$3$subexpression$1",symbols:[{literal:"."},"jsonfloat$ebnf$3$subexpression$1$ebnf$1"]},{name:"jsonfloat$ebnf$3",symbols:["jsonfloat$ebnf$3$subexpression$1"],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$3",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$1",symbols:[{regex:{source:"[+-]",flags:""}}],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$2",symbols:["jsonfloat$ebnf$4$subexpression$1$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"jsonfloat$ebnf$4$subexpression$1",symbols:[{regex:{source:"[eE]",flags:""}},"jsonfloat$ebnf$4$subexpression$1$ebnf$1","jsonfloat$ebnf$4$subexpression$1$ebnf$2"]},{name:"jsonfloat$ebnf$4",symbols:["jsonfloat$ebnf$4$subexpression$1"],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$4",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat",symbols:["jsonfloat$ebnf$1","jsonfloat$ebnf$2","jsonfloat$ebnf$3","jsonfloat$ebnf$4"],postprocess:`
    function(d) {
        return parseFloat(
            (d[0] || "") +
            d[1].join("") +
            (d[2] ? "."+d[2][1].join("") : "") +
            (d[3] ? "e" + (d[3][1] || "+") + d[3][2].join("") : "")
        );
    }
`}],body:[],customTokens:[],config:{},macros:{},start:"unsigned_int",version:"unknown"},exportName$4="grammar";var require$$2={grammar:grammar$4,exportName:exportName$4};const grammar$3={rules:[],body:[`
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function nth(n) {
    return function(d) {
        return d[n];
    };
}
`,`
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function $(o) {
    return function(d) {
        var ret = {};
        Object.keys(o).forEach(function(k) {
            ret[k] = d[o[k]];
        });
        return ret;
    };
}
`],customTokens:[],config:{},macros:{delimited:{args:["el","delim"],exprs:[{tokens:[{mixin:"el"},{ebnf:{subexpression:[{tokens:[{mixin:"delim"},{mixin:"el"}],postprocess:" nth(1) "}]},modifier:":*"}],postprocess:`
    function(d) {
        return [d[0]].concat(d[1]);
    }
`}]}},start:"",version:"unknown"},exportName$3="grammar";var require$$3={grammar:grammar$3,exportName:exportName$3};const grammar$2={rules:[{name:"final$ebnf$1",symbols:[{token:'(lexer.has("ws") ? {type: "ws"} : ws)'}],postprocess:{builtin:"id"}},{name:"final$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:" function(d) { return d[1]; } "},{name:"prog",symbols:["prod"],postprocess:" function(d) { return [d[0]]; } "},{name:"prog",symbols:["prod","ws","prog"],postprocess:" function(d) { return [d[0]].concat(d[2]); } "},{name:"prod",symbols:["word","_",{token:'(lexer.has("arrow") ? {type: "arrow"} : arrow)'},"_","expression+"],postprocess:" function(d) { return {name: d[0], rules: d[4]}; } "},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",{token:'(lexer.has("arrow") ? {type: "arrow"} : arrow)'},"_","expression+"],postprocess:" function(d) {return {macro: d[0], args: d[3], exprs: d[9]}} "},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:" function(d) { return {body: d[2]}; } "},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:" function(d) { return {config: d[1], value: d[3]}; } "},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:" function(d) {return {include: d[2].literal, builtin: false}} "},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:" function(d) {return {include: d[2].literal, builtin: true }} "},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:" function(d) { return d[0].concat([d[4]]); } "},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:" function(d) { return d[0].concat([d[4]]); } "},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:" function(d) { return d[0].concat([d[4]]); } "},{name:"completeexpression",symbols:["expr"],postprocess:" function(d) { return {tokens: d[0]}; } "},{name:"completeexpression",symbols:["expr","_","js"],postprocess:" function(d) { return {tokens: d[0], postprocess: d[2]}; } "},{name:"expr_member",symbols:["word"],postprocess:" id "},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:" function(d) {return {mixin: d[1]}} "},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:" function(d) {return {macrocall: d[0], args: d[3]}} "},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:{builtin:"id"}},{name:"expr_member$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:" function(d) { if (d[1]) {return insensitive(d[0]); } else {return d[0]; } } "},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:" function(d) {return {token: d[1]}} "},{name:"expr_member",symbols:["charclass"],postprocess:" id "},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:" function(d) {return {'subexpression': d[2]} ;} "},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:" function(d) {return {'ebnf': d[0], 'modifier': d[2]}; } "},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:" getValue "},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:" getValue "},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:" getValue "},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:" function(d){ return d[0].concat([d[2]]); } "},{name:"word",symbols:[{token:'(lexer.has("word") ? {type: "word"} : word)'}],postprocess:" getValue "},{name:"string",symbols:[{token:'(lexer.has("string") ? {type: "string"} : string)'}],postprocess:" d => ({literal: d[0].value}) "},{name:"string",symbols:[{token:'(lexer.has("btstring") ? {type: "btstring"} : btstring)'}],postprocess:" d => ({literal: d[0].value}) "},{name:"charclass",symbols:[{token:'(lexer.has("charclass") ? {type: "charclass"} : charclass)'}],postprocess:" getValue "},{name:"js",symbols:[{token:'(lexer.has("js") ? {type: "js"} : js)'}],postprocess:" getValue "},{name:"_$ebnf$1",symbols:["ws"],postprocess:{builtin:"id"}},{name:"_$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[{token:'(lexer.has("ws") ? {type: "ws"} : ws)'}]},{name:"ws$ebnf$1",symbols:[{token:'(lexer.has("ws") ? {type: "ws"} : ws)'}],postprocess:{builtin:"id"}},{name:"ws$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"ws",symbols:["ws$ebnf$1",{token:'(lexer.has("comment") ? {type: "comment"} : comment)'},"_"]}],body:[`
function getValue(d) {
    return d[0].value
}

function literals(list) {
    var rules = {}
    for (var lit of list) {
        rules[lit] = {match: lit, next: 'main'}
    }
    return rules
}

var moo = require('moo')
var rules = Object.assign({
    ws: {match: /\\s+/, lineBreaks: true, next: 'main'},
    comment: /\\#.*/,
    arrow: {match: /[=-]+\\>/, next: 'main'},
    js: {
        match: /\\{\\%(?:[^%]|\\%[^}])*\\%\\}/,
        value: x => x.slice(2, -2),
        lineBreaks: true,
    },
    word: {match: /[\\w\\?\\+]+/, next: 'afterWord'},
    string: {
        match: /"(?:[^\\\\"\\n]|\\\\["\\\\/bfnrt]|\\\\u[a-fA-F0-9]{4})*"/,
        value: x => JSON.parse(x),
        next: 'main',
    },
    btstring: {
        match: /\`[^\`]*\`/,
        value: x => x.slice(1, -1),
        next: 'main',
        lineBreaks: true,
    },
}, literals([
    ",", "|", "$", "%", "(", ")",
    ":?", ":*", ":+",
    "@include", "@builtin", "@",
    "]",
]))

var lexer = moo.states({
    main: Object.assign({}, rules, {
        charclass: {
            match: /\\.|\\[(?:\\\\.|[^\\\\\\n])+?\\]/,
            value: x => new RegExp(x),
        },
    }),
    // Both macro arguments and charclasses are both enclosed in [ ].
    // We disambiguate based on whether the previous token was a \`word\`.
    afterWord: Object.assign({}, rules, {
        "[": {match: "[", next: 'main'},
    }),
})

function insensitive(sl) {
    var s = sl.literal;
    var result = [];
    for (var i=0; i<s.length; i++) {
        var c = s.charAt(i);
        if (c.toUpperCase() !== c || c.toLowerCase() !== c) {
            result.push(new RegExp("[" + c.toLowerCase() + c.toUpperCase() + "]"));
            } else {
            result.push({literal: c});
        }
    }
    return {subexpression: [{tokens: result, postprocess: function(d) {return d.join(""); }}]};
}

`],customTokens:["ws","arrow","word","string","btstring","charclass","js","comment"],config:{lexer:"lexer"},macros:{},start:"final",version:"unknown"},exportName$2="grammar";var require$$4={grammar:grammar$2,exportName:exportName$2};const grammar$1={rules:[{name:"dqstring$ebnf$1",symbols:[]},{name:"dqstring$ebnf$1",symbols:["dqstring$ebnf$1","dstrchar"],postprocess:{builtin:"arrpush"}},{name:"dqstring",symbols:[{literal:'"'},"dqstring$ebnf$1",{literal:'"'}],postprocess:' function(d) {return d[1].join(""); } '},{name:"sqstring$ebnf$1",symbols:[]},{name:"sqstring$ebnf$1",symbols:["sqstring$ebnf$1","sstrchar"],postprocess:{builtin:"arrpush"}},{name:"sqstring",symbols:[{literal:"'"},"sqstring$ebnf$1",{literal:"'"}],postprocess:' function(d) {return d[1].join(""); } '},{name:"btstring$ebnf$1",symbols:[]},{name:"btstring$ebnf$1",symbols:["btstring$ebnf$1",{regex:{source:"[^`]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"btstring",symbols:[{literal:"`"},"btstring$ebnf$1",{literal:"`"}],postprocess:' function(d) {return d[1].join(""); } '},{name:"dstrchar",symbols:[{regex:{source:'[^\\\\"\\n]',flags:""}}],postprocess:" id "},{name:"dstrchar",symbols:[{literal:"\\"},"strescape"],postprocess:`
    function(d) {
        return JSON.parse("\\""+d.join("")+"\\"");
    }
`},{name:"sstrchar",symbols:[{regex:{source:"[^\\\\'\\n]",flags:""}}],postprocess:" id "},{name:"sstrchar",symbols:[{literal:"\\"},"strescape"],postprocess:' function(d) { return JSON.parse("\\""+d.join("")+"\\""); } '},{name:"sstrchar$string$1",symbols:[{literal:"\\"},{literal:"'"}],postprocess:{builtin:"joiner"}},{name:"sstrchar",symbols:["sstrchar$string$1"],postprocess:` function(d) {return "'"; } `},{name:"strescape",symbols:[{regex:{source:'["\\\\/bfnrt]',flags:""}}],postprocess:" id "},{name:"strescape",symbols:[{literal:"u"},{regex:{source:"[a-fA-F0-9]",flags:""}},{regex:{source:"[a-fA-F0-9]",flags:""}},{regex:{source:"[a-fA-F0-9]",flags:""}},{regex:{source:"[a-fA-F0-9]",flags:""}}],postprocess:`
    function(d) {
        return d.join("");
    }
`}],body:[],customTokens:[],config:{},macros:{},start:"dqstring",version:"unknown"},exportName$1="grammar";var require$$5={grammar:grammar$1,exportName:exportName$1};const grammar={rules:[{name:"_$ebnf$1",symbols:[]},{name:"_$ebnf$1",symbols:["_$ebnf$1","wschar"],postprocess:{builtin:"arrpush"}},{name:"_",symbols:["_$ebnf$1"],postprocess:" function(d) {return null;} "},{name:"__$ebnf$1",symbols:["wschar"]},{name:"__$ebnf$1",symbols:["__$ebnf$1","wschar"],postprocess:{builtin:"arrpush"}},{name:"__",symbols:["__$ebnf$1"],postprocess:" function(d) {return null;} "},{name:"wschar",symbols:[{regex:{source:"[ \\t\\n\\v\\f]",flags:""}}],postprocess:" id "}],body:[],customTokens:[],config:{},macros:{},start:"_",version:"unknown"},exportName="grammar";var require$$6={grammar,exportName},nearley$1={exports:{}},moo={exports:{}};(function(a){(function(e,r){a.exports?a.exports=r():e.moo=r()})(commonjsGlobal,function(){var e=Object.prototype.hasOwnProperty,r=Object.prototype.toString,t=typeof new RegExp().sticky=="boolean";function n(i){return i&&r.call(i)==="[object RegExp]"}function o(i){return i&&typeof i=="object"&&!n(i)&&!Array.isArray(i)}function l(i){return i.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function c(i){var u=new RegExp("|"+i);return u.exec("").length-1}function h(i){return"("+i+")"}function s(i){if(!i.length)return"(?!)";var u=i.map(function(p){return"(?:"+p+")"}).join("|");return"(?:"+u+")"}function $(i){if(typeof i=="string")return"(?:"+l(i)+")";if(n(i)){if(i.ignoreCase)throw new Error("RegExp /i flag not allowed");if(i.global)throw new Error("RegExp /g flag is implied");if(i.sticky)throw new Error("RegExp /y flag is implied");if(i.multiline)throw new Error("RegExp /m flag is implied");return i.source}else throw new Error("Not a pattern: "+i)}function y(i){for(var u=Object.getOwnPropertyNames(i),p=[],m=0;m<u.length;m++){var b=u[m],d=i[b],g=[].concat(d);if(b==="include"){for(var v=0;v<g.length;v++)p.push({include:g[v]});continue}var w=[];g.forEach(function(f){o(f)?(w.length&&p.push(x(b,w)),p.push(x(b,f)),w=[]):w.push(f)}),w.length&&p.push(x(b,w))}return p}function k(i){for(var u=[],p=0;p<i.length;p++){var m=i[p];if(m.include){for(var b=[].concat(m.include),d=0;d<b.length;d++)u.push({include:b[d]});continue}if(!m.type)throw new Error("Rule has no type: "+JSON.stringify(m));u.push(x(m.type,m))}return u}function x(i,u){if(o(u)||(u={match:u}),u.include)throw new Error("Matching rules cannot also include states");var p={defaultType:i,lineBreaks:!!u.error||!!u.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var m in u)e.call(u,m)&&(p[m]=u[m]);if(typeof p.type=="string"&&i!==p.type)throw new Error("Type transform cannot be a string (type '"+p.type+"' for token '"+i+"')");var b=p.match;return p.match=Array.isArray(b)?b:b?[b]:[],p.match.sort(function(d,g){return n(d)&&n(g)?0:n(g)?-1:n(d)?1:g.length-d.length}),p}function R(i){return Array.isArray(i)?k(i):y(i)}var A=x("error",{lineBreaks:!0,shouldThrow:!0});function q(i,u){for(var p=null,m=Object.create(null),b=!0,d=null,g=[],v=[],w=0;w<i.length;w++)i[w].fallback&&(b=!1);for(var w=0;w<i.length;w++){var f=i[w];if(f.include)throw new Error("Inheritance is not allowed in stateless lexers");if(f.error||f.fallback){if(p)throw!f.fallback==!p.fallback?new Error("Multiple "+(f.fallback?"fallback":"error")+" rules not allowed (for token '"+f.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+f.defaultType+"')");p=f}var _=f.match.slice();if(b)for(;_.length&&typeof _[0]=="string"&&_[0].length===1;){var N=_.shift();m[N.charCodeAt(0)]=f}if(f.pop||f.push||f.next){if(!u)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+f.defaultType+"')");if(f.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+f.defaultType+"')")}if(_.length!==0){b=!1,g.push(f);for(var S=0;S<_.length;S++){var E=_[S];if(!!n(E)){if(d===null)d=E.unicode;else if(d!==E.unicode&&f.fallback===!1)throw new Error("If one rule is /u then all must be")}}var C=s(_.map($)),O=new RegExp(C);if(O.test(""))throw new Error("RegExp matches empty string: "+O);var T=c(C);if(T>0)throw new Error("RegExp has capture groups: "+O+`
Use (?: \u2026 ) instead`);if(!f.lineBreaks&&O.test(`
`))throw new Error("Rule should declare lineBreaks: "+O);v.push(h(C))}}var P=p&&p.fallback,B=t&&!P?"ym":"gm",M=t||P?"":"|";d===!0&&(B+="u");var H=new RegExp(s(v)+M,B);return{regexp:H,groups:g,fast:m,error:p||A}}function I(i){var u=q(R(i));return new j({start:u},"start")}function J(i,u,p){var m=i&&(i.push||i.next);if(m&&!p[m])throw new Error("Missing state '"+m+"' (in token '"+i.defaultType+"' of state '"+u+"')");if(i&&i.pop&&+i.pop!=1)throw new Error("pop must be 1 (in token '"+i.defaultType+"' of state '"+u+"')")}function G(i,u){var p=i.$all?R(i.$all):[];delete i.$all;var m=Object.getOwnPropertyNames(i);u||(u=m[0]);for(var b=Object.create(null),d=0;d<m.length;d++){var g=m[d];b[g]=R(i[g]).concat(p)}for(var d=0;d<m.length;d++)for(var g=m[d],v=b[g],w=Object.create(null),f=0;f<v.length;f++){var _=v[f];if(!!_.include){var N=[f,1];if(_.include!==g&&!w[_.include]){w[_.include]=!0;var S=b[_.include];if(!S)throw new Error("Cannot include nonexistent state '"+_.include+"' (in state '"+g+"')");for(var E=0;E<S.length;E++){var C=S[E];v.indexOf(C)===-1&&N.push(C)}}v.splice.apply(v,N),f--}}for(var O=Object.create(null),d=0;d<m.length;d++){var g=m[d];O[g]=q(b[g],!0)}for(var d=0;d<m.length;d++){for(var T=m[d],P=O[T],B=P.groups,f=0;f<B.length;f++)J(B[f],T,O);for(var M=Object.getOwnPropertyNames(P.fast),f=0;f<M.length;f++)J(P.fast[M[f]],T,O)}return new j(O,u)}function z(i){for(var u=Object.create(null),p=Object.create(null),m=Object.getOwnPropertyNames(i),b=0;b<m.length;b++){var d=m[b],g=i[d],v=Array.isArray(g)?g:[g];v.forEach(function(S){if((p[S.length]=p[S.length]||[]).push(S),typeof S!="string")throw new Error("keyword must be string (in keyword '"+d+"')");u[S]=d})}function w(S){return JSON.stringify(S)}var f="";f+=`switch (value.length) {
`;for(var _ in p){var N=p[_];f+="case "+_+`:
`,f+=`switch (value) {
`,N.forEach(function(S){var E=u[S];f+="case "+w(S)+": return "+w(E)+`
`}),f+=`}
`}return f+=`}
`,Function("value",f)}var j=function(i,u){this.startState=u,this.states=i,this.buffer="",this.stack=[],this.reset()};j.prototype.reset=function(i,u){return this.buffer=i||"",this.index=0,this.line=u?u.line:1,this.col=u?u.col:1,this.queuedToken=u?u.queuedToken:null,this.queuedThrow=u?u.queuedThrow:null,this.setState(u?u.state:this.startState),this.stack=u&&u.stack?u.stack.slice():[],this},j.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},j.prototype.setState=function(i){if(!(!i||this.state===i)){this.state=i;var u=this.states[i];this.groups=u.groups,this.error=u.error,this.re=u.regexp,this.fast=u.fast}},j.prototype.popState=function(){this.setState(this.stack.pop())},j.prototype.pushState=function(i){this.stack.push(this.state),this.setState(i)};var L=t?function(i,u){return i.exec(u)}:function(i,u){var p=i.exec(u);return p[0].length===0?null:p};j.prototype._getGroup=function(i){for(var u=this.groups.length,p=0;p<u;p++)if(i[p+1]!==void 0)return this.groups[p];throw new Error("Cannot find token type for matched text")};function D(){return this.value}if(j.prototype.next=function(){var i=this.index;if(this.queuedGroup){var u=this._token(this.queuedGroup,this.queuedText,i);return this.queuedGroup=null,this.queuedText="",u}var p=this.buffer;if(i!==p.length){var g=this.fast[p.charCodeAt(i)];if(g)return this._token(g,p.charAt(i),i);var m=this.re;m.lastIndex=i;var b=L(m,p),d=this.error;if(b==null)return this._token(d,p.slice(i,p.length),i);var g=this._getGroup(b),v=b[0];return d.fallback&&b.index!==i?(this.queuedGroup=g,this.queuedText=v,this._token(d,p.slice(i,b.index),i)):this._token(g,v,i)}},j.prototype._token=function(i,u,p){var m=0;if(i.lineBreaks){var b=/\n/g,d=1;if(u===`
`)m=1;else for(;b.exec(u);)m++,d=b.lastIndex}var g={type:typeof i.type=="function"&&i.type(u)||i.defaultType,value:typeof i.value=="function"?i.value(u):u,text:u,toString:D,offset:p,lineBreaks:m,line:this.line,col:this.col},v=u.length;if(this.index+=v,this.line+=m,m!==0?this.col=v-d+1:this.col+=v,i.shouldThrow)throw new Error(this.formatError(g,"invalid syntax"));return i.pop?this.popState():i.push?this.pushState(i.push):i.next&&this.setState(i.next),g},typeof Symbol!="undefined"&&Symbol.iterator){var F=function(i){this.lexer=i};F.prototype.next=function(){var i=this.lexer.next();return{value:i,done:!i}},F.prototype[Symbol.iterator]=function(){return this},j.prototype[Symbol.iterator]=function(){return new F(this)}}return j.prototype.formatError=function(i,u){if(i==null)var p=this.buffer.slice(this.index),i={text:p,offset:this.index,lineBreaks:p.indexOf(`
`)===-1?0:1,line:this.line,col:this.col};var m=Math.max(0,i.offset-i.col+1),b=i.lineBreaks?i.text.indexOf(`
`):i.text.length,d=this.buffer.substring(m,i.offset+b);return u+=" at line "+i.line+" col "+i.col+`:

`,u+="  "+d+`
`,u+="  "+Array(i.col).join(" ")+"^",u},j.prototype.clone=function(){return new j(this.states,this.state)},j.prototype.has=function(i){return!0},{compile:I,states:G,error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:z}})})(moo),function(a){(function(){function e(s){return s[0]}function r(s){return s[0].value}function t(s){var $={};for(var y of s)$[y]={match:y,next:"main"};return $}var n=moo.exports,o=Object.assign({ws:{match:/\s+/,lineBreaks:!0,next:"main"},comment:/\#.*/,arrow:{match:/[=-]+\>/,next:"main"},js:{match:/\{\%(?:[^%]|\%[^}])*\%\}/,value:s=>s.slice(2,-2),lineBreaks:!0},word:{match:/[\w\?\+]+/,next:"afterWord"},string:{match:/"(?:[^\\"\n]|\\["\\/bfnrt]|\\u[a-fA-F0-9]{4})*"/,value:s=>JSON.parse(s),next:"main"},btstring:{match:/`[^`]*`/,value:s=>s.slice(1,-1),next:"main",lineBreaks:!0}},t([",","|","$","%","(",")",":?",":*",":+","@include","@builtin","@","]"])),l=n.states({main:Object.assign({},o,{charclass:{match:/\.|\[(?:\\.|[^\\\n])+?\]/,value:s=>new RegExp(s)}}),afterWord:Object.assign({},o,{"[":{match:"[",next:"main"}})});function c(s){for(var $=s.literal,y=[],k=0;k<$.length;k++){var x=$.charAt(k);x.toUpperCase()!==x||x.toLowerCase()!==x?y.push(new RegExp("["+x.toLowerCase()+x.toUpperCase()+"]")):y.push({literal:x})}return{subexpression:[{tokens:y,postprocess:function(R){return R.join("")}}]}}var h={lexer:l,rules:[{name:"final$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"final$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:function(s){return s[1]}},{name:"prog",symbols:["prod"],postprocess:function(s){return[s[0]]}},{name:"prog",symbols:["prod","ws","prog"],postprocess:function(s){return[s[0]].concat(s[2])}},{name:"prod",symbols:["word","_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{name:s[0],rules:s[4]}}},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{macro:s[0],args:s[3],exprs:s[9]}}},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:function(s){return{body:s[2]}}},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:function(s){return{config:s[1],value:s[3]}}},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!1}}},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!0}}},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"completeexpression",symbols:["expr"],postprocess:function(s){return{tokens:s[0]}}},{name:"completeexpression",symbols:["expr","_","js"],postprocess:function(s){return{tokens:s[0],postprocess:s[2]}}},{name:"expr_member",symbols:["word"],postprocess:e},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:function(s){return{mixin:s[1]}}},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:function(s){return{macrocall:s[0],args:s[3]}}},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:e},{name:"expr_member$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:function(s){return s[1]?c(s[0]):s[0]}},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:function(s){return{token:s[1]}}},{name:"expr_member",symbols:["charclass"],postprocess:e},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:function(s){return{subexpression:s[2]}}},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:function(s){return{ebnf:s[0],modifier:s[2]}}},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:r},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:r},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:r},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:function(s){return s[0].concat([s[2]])}},{name:"word",symbols:[l.has("word")?{type:"word"}:word],postprocess:r},{name:"string",symbols:[l.has("string")?{type:"string"}:string],postprocess:s=>({literal:s[0].value})},{name:"string",symbols:[l.has("btstring")?{type:"btstring"}:btstring],postprocess:s=>({literal:s[0].value})},{name:"charclass",symbols:[l.has("charclass")?{type:"charclass"}:charclass],postprocess:r},{name:"js",symbols:[l.has("js")?{type:"js"}:js],postprocess:r},{name:"_$ebnf$1",symbols:["ws"],postprocess:e},{name:"_$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[l.has("ws")?{type:"ws"}:ws]},{name:"ws$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"ws$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"ws",symbols:["ws$ebnf$1",l.has("comment")?{type:"comment"}:comment,"_"]}],start:"final"};a.exports=h})()}(nearley$1);var grammarWell={exports:{}};(function(a){(function(){function e(s){return s[0]}function r(s){return s[0].value}function t(s){var $={};for(var y of s)$[y]={match:y,next:"main"};return $}var n=moo.exports,o=Object.assign({ws:{match:/\s+/,lineBreaks:!0,next:"main"},comment:/\#.*/,arrow:{match:/[=-]+\>/,next:"main"},js:{match:/\{\%(?:[^%]|\%[^}])*\%\}/,value:s=>s.slice(2,-2),lineBreaks:!0},js2:{match:/\$\{(?:.*)\}/,value:s=>s.slice(2,-1),lineBreaks:!0},word:{match:/[\w\?\+]+/,next:"afterWord"},string:{match:/"(?:[^\\"\n]|\\["\\/bfnrt]|\\u[a-fA-F0-9]{4})*"/,value:s=>JSON.parse(s),next:"main"},btstring:{match:/`[^`]*`/,value:s=>s.slice(1,-1),next:"main",lineBreaks:!0}},t([",","|","$","%","(",")",":?",":*",":+","@include","@builtin","@","]"])),l=n.states({main:Object.assign({},o,{charclass:{match:/\.|\[(?:\\.|[^\\\n])+?\]/,value:s=>new RegExp(s)}}),afterWord:Object.assign({},o,{"[":{match:"[",next:"main"}})});function c(s){for(var $=s.literal,y=[],k=0;k<$.length;k++){var x=$.charAt(k);x.toUpperCase()!==x||x.toLowerCase()!==x?y.push(new RegExp("["+x.toLowerCase()+x.toUpperCase()+"]")):y.push({literal:x})}return{subexpression:[{tokens:y,postprocess:function(R){return R.join("")}}]}}var h={lexer:l,rules:[{name:"final$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"final$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:function(s){return s[1]}},{name:"prog",symbols:["prod"],postprocess:function(s){return[s[0]]}},{name:"prog",symbols:["prod","ws","prog"],postprocess:function(s){return[s[0]].concat(s[2])}},{name:"prod",symbols:["word","_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{name:s[0],rules:s[4]}}},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{macro:s[0],args:s[3],exprs:s[9]}}},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:function(s){return{body:s[2]}}},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:function(s){return{config:s[1],value:s[3]}}},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!1}}},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!0}}},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"completeexpression",symbols:["expr"],postprocess:function(s){return{tokens:s[0]}}},{name:"completeexpression",symbols:["expr","_","js"],postprocess:function(s){return{tokens:s[0],postprocess:s[2]}}},{name:"completeexpression",symbols:["expr","_","js2"],postprocess:function(s){return{tokens:s[0],transform:s[2]}}},{name:"expr_member",symbols:["word"],postprocess:e},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:function(s){return{mixin:s[1]}}},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:function(s){return{macrocall:s[0],args:s[3]}}},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:e},{name:"expr_member$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:function(s){return s[1]?c(s[0]):s[0]}},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:function(s){return{token:s[1]}}},{name:"expr_member",symbols:["charclass"],postprocess:e},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:function(s){return{subexpression:s[2]}}},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:function(s){return{ebnf:s[0],modifier:s[2]}}},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:r},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:r},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:r},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:function(s){return s[0].concat([s[2]])}},{name:"word",symbols:[l.has("word")?{type:"word"}:word],postprocess:r},{name:"string",symbols:[l.has("string")?{type:"string"}:string],postprocess:s=>({literal:s[0].value})},{name:"string",symbols:[l.has("btstring")?{type:"btstring"}:btstring],postprocess:s=>({literal:s[0].value})},{name:"charclass",symbols:[l.has("charclass")?{type:"charclass"}:charclass],postprocess:r},{name:"js",symbols:[l.has("js")?{type:"js"}:js],postprocess:r},{name:"js2",symbols:[l.has("js2")?{type:"js2"}:js2],postprocess:r},{name:"_$ebnf$1",symbols:["ws"],postprocess:e},{name:"_$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[l.has("ws")?{type:"ws"}:ws]},{name:"ws$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"ws$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"ws",symbols:["ws$ebnf$1",l.has("comment")?{type:"comment"}:comment,"_"]}],start:"final"};a.exports=h})()})(grammarWell),Object.defineProperty(grammarBuilder,"__esModule",{value:!0}),grammarBuilder.GrammarBuilder=void 0;const interpreter_1=interpreter,cow=require$$1,number=require$$2,postprocessor=require$$3,nearley=require$$4,string$1=require$$5,whitespace=require$$6,BuiltInRegistry={"cow.ne":cow,"number.ne":number,"postprocessor.ne":postprocessor,"nearley.ne":nearley,"string.ne":string$1,"whitespace.ne":whitespace};class GrammarBuilder{constructor(e,r){this.config=e,this.compilerState=r,this.names=Object.create(null),this.neInterpreter=new interpreter_1.Interpreter(nearley$1.exports),this.grmrInterpreter=new interpreter_1.Interpreter(grammarWell.exports),this.state={rules:[],body:[],customTokens:new Set,config:{},macros:{},start:"",version:"unknown"},this.state.version=e.version||this.state.version}import(e,r="grammar-well"){if(typeof e=="string"){const t=this.mergeGrammarString(e,r);this.state.start=this.state.start||t.start;return}e=Array.isArray(e)?e:[e];for(const t of e)if("body"in t){if(this.config.noscript)continue;this.state.body.push(t.body)}else"include"in t?t.builtin?this.includeBuiltIn(t.include):this.includeGrammar(t.include):"macro"in t?this.state.macros[t.macro]={args:t.args,exprs:t.exprs}:"config"in t?this.state.config[t.config]=t.value:(this.buildRules(t.name,t.rules,{}),this.state.start=this.state.start||t.name)}export(){return this.state}includeBuiltIn(e){if(e=e.toLowerCase(),!this.compilerState.alreadycompiled.has(e)){if(this.compilerState.alreadycompiled.add(e),!BuiltInRegistry[e])return;const{grammar:r}=BuiltInRegistry[e];for(const{symbols:t}of r.rules)for(let n=0;n<t.length;n++){const o=t[n];typeof o=="object"&&"regex"in o&&(t[n]=new RegExp(o.regex.source,o.regex.flags))}this.merge(BuiltInRegistry[e].grammar)}}includeGrammar(e){const r=this.compilerState.resolver,t=r.path(e);this.compilerState.alreadycompiled.has(t)||(this.compilerState.alreadycompiled.add(t),this.mergeGrammarString(r.body(t),t.slice(-3)===".ne"?"nearley":"grammar-well"))}mergeGrammarString(e,r="grammar-well"){const t=new GrammarBuilder(this.config,this.compilerState);r=="nearley"?t.import(this.neInterpreter.run(e)):t.import(this.grmrInterpreter.run(e));const n=t.export();return this.merge(n),n}merge(e){this.state.rules.push(...e.rules),this.state.body.push(...e.body),e.customTokens.forEach(r=>this.state.customTokens.add(r)),Object.assign(this.state.config,e.config),Object.assign(this.state.macros,e.macros)}uuid(e){return this.names[e]=(this.names[e]||0)+1,e+"$"+this.names[e]}buildRules(e,r,t){for(let n=0;n<r.length;n++){const o=this.buildRule(e,r[n],t);this.config.noscript&&(o.postprocess=null,o.transform=null),this.state.rules.push(o)}}buildRule(e,r,t){const n=[];for(let o=0;o<r.tokens.length;o++){const l=this.buildSymbol(e,r.tokens[o],t);l!==null&&n.push(l)}return{name:e,symbols:n,postprocess:r.postprocess,transform:r.transform}}buildSymbol(e,r,t){if(typeof r=="string")return r==="null"?null:r;if(r instanceof RegExp)return r;if("literal"in r)return r.literal.length?r.literal.length===1||this.state.config.lexer?r:this.buildStringToken(e,r,t):null;if("token"in r){if(this.state.config.lexer){const n=r.token;return this.state.customTokens.add(n),{token:`(${this.state.config.lexer}.has(${JSON.stringify(n)}) ? {type: ${JSON.stringify(n)}} : ${n})`}}return r}if("subexpression"in r)return this.buildSubExpressionToken(e,r,t);if("ebnf"in r)return this.buildEBNFToken(e,r,t);if("macrocall"in r)return this.buildMacroCallToken(e,r,t);if("mixin"in r){if(t[r.mixin])return this.buildSymbol(e,t[r.mixin],t);throw new Error("Unbound variable: "+r.mixin)}throw new Error("unrecognized token: "+JSON.stringify(r))}buildStringToken(e,r,t){const n=this.uuid(e+"$string");return this.buildRules(n,[{tokens:r.literal.split("").map(o=>({literal:o})),postprocess:{builtin:"joiner"}}],t),n}buildSubExpressionToken(e,r,t){const n=this.uuid(e+"$subexpression");return this.buildRules(n,r.subexpression,t),n}buildEBNFToken(e,r,t){const n=this.uuid(e+"$ebnf");let o={tokens:[]},l={tokens:[]};return r.modifier==":+"?(o.tokens=[r.ebnf],l.tokens=[n,r.ebnf],l.postprocess={builtin:"arrpush"}):r.modifier==":*"?(l.tokens=[n,r.ebnf],l.postprocess={builtin:"arrpush"}):r.modifier==":?"&&(o.tokens=[r.ebnf],o.postprocess={builtin:"id"},l.postprocess={builtin:"nuller"}),this.buildRules(n,[o,l],t),n}buildMacroCallToken(e,r,t){const n=this.uuid(e+"$macrocall"),o=this.state.macros[r.macrocall];if(!o)throw new Error("Unkown macro: "+r.macrocall);if(o.args.length!==r.args.length)throw new Error("Argument count mismatch.");const l={__proto__:t};for(let c=0;c<o.args.length;c++){const h=this.uuid(e+"$macrocall");l[o.args[c]]=h,this.buildRules(h,[r.args[c]],t)}return this.buildRules(n,o.exprs,l),n}}grammarBuilder.GrammarBuilder=GrammarBuilder;var coffeescript={},util={};Object.defineProperty(util,"__esModule",{value:!0}),util.serializeRule=util.serializeSymbol=util.tabulateString=util.dedentFunc=util.serializeRules=void 0;function serializeRules(a,e,r=""){return`[
    `+a.map(function(t){return serializeRule(t,e)}).join(`,
    `)+`
`+r+"]"}util.serializeRules=serializeRules;function dedentFunc(a){var e=a.toString().split(/\n/);if(e.length===1)return[e[0].replace(/^\s+|\s+$/g,"")];for(var r=null,t=e.slice(1),n=0;n<t.length;n++){var o=/^\s*/.exec(t[n]);o&&o[0].length!==t[n].length&&(r===null||o[0].length<r.length)&&(r=o[0])}return r===null?e:e.map(function(c){return c.slice(0,r.length)===r?c.slice(r.length):c})}util.dedentFunc=dedentFunc;function tabulateString(a,e,r={}){var t;Array.isArray(a)?t=a:t=a.toString().split(`
`);var n=t.map(function(l,c){var h=!0;return c==0&&!r.indentFirst&&(h=!1),h?e+l:l}).join(`
`);return n}util.tabulateString=tabulateString;function serializeSymbol(a){return a instanceof RegExp?a.toString():a.token?a.token:JSON.stringify(a)}util.serializeSymbol=serializeSymbol;function serializeRule(a,e){var r="{";return r+='"name": '+JSON.stringify(a.name),r+=', "symbols": ['+a.symbols.map(serializeSymbol).join(", ")+"]",a.transform?r+=', "transform": '+tabulateString(dedentFunc(a.transform),"        ",{indentFirst:!1}):a.postprocess&&(a.postprocess.builtin&&(a.postprocess=e[a.postprocess.builtin]),r+=', "postprocess": '+tabulateString(dedentFunc(a.postprocess),"        ",{indentFirst:!1})),r+="}",r}util.serializeRule=serializeRule,Object.defineProperty(coffeescript,"__esModule",{value:!0}),coffeescript.CoffeescriptOutput=void 0;const util_1$1=util,CoffeescriptPostProcessors={joiner:"(d) -> d.join('')",arrconcat:"(d) -> [d[0]].concat(d[1])",arrpush:"(d) -> d[0].concat([d[1]])",nuller:"() -> null",id:"id"};function CoffeescriptOutput(a,e){return`# Generated automatically by nearley, version ${a.version}
# http://github.com/Hardmath123/nearley
do ->
  id = (d) -> d[0]
${(0,util_1$1.tabulateString)((0,util_1$1.dedentFunc)(a.body.join(`
`)),"  ")}
  grammar = {
    lexer: ${a.config.lexer},
    rules: ${(0,util_1$1.tabulateString)((0,util_1$1.serializeRules)(a.rules,CoffeescriptPostProcessors),"      ",{indentFirst:!1})},
    start: ${JSON.stringify(a.start)}
  }
  if typeof module != 'undefined' && typeof module.exports != 'undefined'
    module.exports = grammar;
  else
    window.${e} = grammar;
`}coffeescript.CoffeescriptOutput=CoffeescriptOutput;var javascript={};(function(a){Object.defineProperty(a,"__esModule",{value:!0}),a.ESMOutput=a.JavascriptOutput=a.JavascriptPostProcessors=void 0;const e=util;a.JavascriptPostProcessors={joiner:"function joiner(d) {return d.join('');}",arrconcat:"function arrconcat(d) {return [d[0]].concat(d[1]);}",arrpush:"function arrpush(d) {return d[0].concat([d[1]]);}",nuller:"function(d) {return null;}",id:"id"};function r(n,o){return`// Generated automatically by nearley, version ${n.version} 
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }
${n.body.join(`
`)}
var grammar = {
    lexer: ${n.config.lexer},
    rules: ${(0,e.serializeRules)(n.rules,a.JavascriptPostProcessors)},
    start: ${JSON.stringify(n.start)}
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.${o} = grammar;
}
})();
`}a.JavascriptOutput=r;function t(n,o){return`// Generated automatically by nearley, version ${n.version} 
// http://github.com/Hardmath123/nearley
function id(x) { return x[0]; }
${n.body.join(`
`)}
export default { 
    lexer: ${n.config.lexer},
    rules: ${(0,e.serializeRules)(n.rules,a.JavascriptPostProcessors)},
    start: ${JSON.stringify(n.start)}
};
`}a.ESMOutput=t})(javascript);var typescript={};Object.defineProperty(typescript,"__esModule",{value:!0}),typescript.TypescriptFormat=void 0;const util_1=util,TypescriptPostProcessors={joiner:"(d) => d.join('')",arrconcat:"(d) => [d[0]].concat(d[1])",arrpush:"(d) => d[0].concat([d[1]])",nuller:"() => null",id:"id"};function TypescriptFormat(a,e){return`// Generated automatically by nearley, version ${a.version}
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d: any[]): any { return d[0]; }
${Array.from(a.customTokens).map(function(r){return"declare var "+r+`: any;
`}).join("")}
${a.body.join(`
`)}

interface NearleyToken {
    value: any;
    [key: string]: any;
};

interface NearleyLexer {
    reset: (chunk: string, info: any) => void;
    next: () => NearleyToken | undefined;
    save: () => any;
    formatError: (token: never) => string;
    has: (tokenType: string) => boolean;
};

interface NearleyRule {
    name: string;
    symbols: NearleySymbol[];
    postprocess?: (d: any[], loc?: number, reject?: {}) => any;
};

type NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };

interface Grammar {
    lexer: NearleyLexer | undefined;
    rules: NearleyRule[];
    start: string;
};

const grammar: Grammar = {
    lexer: ${a.config.lexer},
    rules: ${(0,util_1.serializeRules)(a.rules,TypescriptPostProcessors,"  ")},
    start: ${JSON.stringify(a.start)},
};

export default grammar;
`}typescript.TypescriptFormat=TypescriptFormat;var json={};Object.defineProperty(json,"__esModule",{value:!0}),json.JSONFormatter=void 0;function JSONFormatter(a,e){const r=[];for(const t of a.rules)r.push(Object.assign(Object.assign({},t),{symbols:t.symbols.map(n=>n instanceof RegExp?{regex:{source:n.source,flags:n.flags}}:n)}));return JSON.stringify({grammar:Object.assign(Object.assign({},a),{rules:r,customTokens:Array.from(a.customTokens)}),exportName:e})}json.JSONFormatter=JSONFormatter,Object.defineProperty(compiler,"__esModule",{value:!0}),compiler.Compiler=compiler.Compile=void 0;const import_resolver_1=importResolver,grammar_builder_1=grammarBuilder,coffeescript_1=coffeescript,javascript_1=javascript,typescript_1=typescript,json_1=json,OutputFormats={_default:javascript_1.JavascriptOutput,object:(a,e)=>({grammar:a,exportName:e}),json:json_1.JSONFormatter,js:javascript_1.JavascriptOutput,javascript:javascript_1.JavascriptOutput,module:javascript_1.ESMOutput,esmodule:javascript_1.ESMOutput,cs:coffeescript_1.CoffeescriptOutput,coffee:coffeescript_1.CoffeescriptOutput,coffeescript:coffeescript_1.CoffeescriptOutput,ts:typescript_1.TypescriptFormat,typescript:typescript_1.TypescriptFormat};function Compile(a,e={}){const r=new Compiler(e);return r.import(a,e.language),r.export(e.format)}compiler.Compile=Compile;class Compiler{constructor(e={}){this.state={alreadycompiled:new Set,resolver:e.resolverInstance?e.resolverInstance:e.resolver?new e.resolver(e.basedir):new import_resolver_1.FileSystemResolver(e.basedir)},this.grammarBuilder=new grammar_builder_1.GrammarBuilder(e,this.state)}import(e,r){this.grammarBuilder.import(e,r)}export(e,r="grammar"){const t=this.grammarBuilder.export(),n=e||t.config.preprocessor||"_default";if(OutputFormats[n])return OutputFormats[n](t,r);throw new Error("No such preprocessor: "+n)}}compiler.Compiler=Compiler;var lint$1={};Object.defineProperty(lint$1,"__esModule",{value:!0}),lint$1.lint=void 0;function warn(a,e){a.out.write("WARN	"+e+`
`)}function lintNames(a,e){const r=new Set,{rules:t}=a;t.forEach(n=>r.add(n.name));for(const n of t)for(const o of n.symbols)!o.literal&&!o.token&&o.constructor!==RegExp&&(r.has(o)||warn(e,"Undefined symbol `"+o+"` used."))}function lint(a,e){e.out||(e.out=process.stderr),lintNames(a,e)}lint$1.lint=lint,function(a){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(t,n,o,l){l===void 0&&(l=o);var c=Object.getOwnPropertyDescriptor(n,o);(!c||("get"in c?!n.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return n[o]}}),Object.defineProperty(t,l,c)}:function(t,n,o,l){l===void 0&&(l=o),t[l]=n[o]}),r=commonjsGlobal&&commonjsGlobal.__exportStar||function(t,n){for(var o in t)o!=="default"&&!Object.prototype.hasOwnProperty.call(n,o)&&e(n,t,o)};Object.defineProperty(a,"__esModule",{value:!0}),r(compiler,a),r(grammarBuilder,a),r(lint$1,a),r(interpreter,a),r(parser$1,a),r(lexer,a)}(build),onmessage=a=>{const e=JSON.parse(JSON.stringify(TestGrammar(a.data.grammar,a.data.input)));postMessage(e)};function TestGrammar(a,e){try{const r=build.Compile(a,{resolverInstance:{body:()=>"",path:()=>""}}),t=exports$1(r);return{result:new build.Interpreter(t).run(e)}}catch(r){return{error:r}}}function exports$1(source){let module={exports:""};return eval(source),module.exports}})();
