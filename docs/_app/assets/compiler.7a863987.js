(function(){"use strict";var commonjsGlobal=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function getAugmentedNamespace(a){if(a.__esModule)return a;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(a).forEach(function(t){var r=Object.getOwnPropertyDescriptor(a,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:function(){return a[t]}})}),e}var build={},compiler={},importResolver={},__viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze({__proto__:null,default:__viteBrowserExternal}),require$$2$1=getAugmentedNamespace(__viteBrowserExternal$1),__awaiter$2=commonjsGlobal&&commonjsGlobal.__awaiter||function(a,e,t,r){function n(i){return i instanceof t?i:new t(function(l){l(i)})}return new(t||(t=Promise))(function(i,l){function c(f){try{s(r.next(f))}catch(m){l(m)}}function b(f){try{s(r.throw(f))}catch(m){l(m)}}function s(f){f.done?i(f.value):n(f.value).then(c,b)}s((r=r.apply(a,e||[])).next())})};Object.defineProperty(importResolver,"__esModule",{value:!0});var BrowserImportResolver_1=importResolver.BrowserImportResolver=importResolver.FileSystemResolver=void 0;class FileSystemResolver{constructor(e){const{readFile:t}=require$$2$1,{resolve:r,dirname:n}=require$$2$1,{promisify:i}=require$$2$1;this.readFile=i(t),this.resolve=r,this.baseDir=e?n(e):process==null?void 0:process.cwd()}path(e){return this.resolve(this.baseDir,e)}body(e){return this.readFile(e,"utf-8")}}importResolver.FileSystemResolver=FileSystemResolver;class BrowserImportResolver{constructor(e){this.baseURL=e}path(e){return new URL(e,this.baseURL).href}body(e){return __awaiter$2(this,void 0,void 0,function*(){return(yield fetch(e)).text()})}}BrowserImportResolver_1=importResolver.BrowserImportResolver=BrowserImportResolver;var generator={},parser$2={},parser$1={},column$1={},state$1={};Object.defineProperty(state$1,"__esModule",{value:!0}),state$1.State=void 0;const parser_1$5=parser$1;class State$1{constructor(e,t,r,n){this.rule=e,this.dot=t,this.reference=r,this.wantedBy=n,this.data=[],this.isComplete=this.dot===e.symbols.length}nextState(e){const t=new State$1(this.rule,this.dot+1,this.reference,this.wantedBy);return t.left=this,t.right=e,t.isComplete&&(t.data=t.build(),t.right=void 0),t}build(){const e=[];let t=this;do e.push(t.right.data),t=t.left;while(t.left);return e.reverse(),e}finish(){this.rule.transform?this.data=this.rule.transform({data:this.data,reference:this.reference,dot:this.dot,name:this.rule.name,reject:parser_1$5.NearleyParser.fail}):this.rule.postprocess&&(this.data=this.rule.postprocess(this.data,this.reference,parser_1$5.NearleyParser.fail))}}state$1.State=State$1,Object.defineProperty(column$1,"__esModule",{value:!0}),column$1.Column=void 0;const parser_1$4=parser$1,state_1$1=state$1;class Column$1{constructor(e,t){this.ruleMap=e,this.index=t,this.states=[],this.wants=Object.create(null),this.scannable=[],this.completed=Object.create(null)}process(e){let t=0,r;for(;r=this.states[t++];)if(r.isComplete){if(r.finish(),r.data!==parser_1$4.NearleyParser.fail){const{wantedBy:n}=r;for(let i=n.length;i--;)this.complete(n[i],r);if(r.reference===this.index){const{name:i}=r.rule;this.completed[i]=this.completed[i]||[],this.completed[i].push(r)}}}else{const n=r.rule.symbols[r.dot];if(typeof n!="string"){this.scannable.push(r);continue}if(this.wants[n]){if(this.wants[n].push(r),this.completed[n])for(const i of this.completed[n])this.complete(r,i)}else this.wants[n]=[r],this.predict(n)}}predict(e){if(!!this.ruleMap[e])for(const t of this.ruleMap[e])this.states.push(new state_1$1.State(t,0,this.index,this.wants[e]))}complete(e,t){const r=e.nextState(t);this.states.push(r)}}column$1.Column=Column$1;var errorReporting$1={},message={};Object.defineProperty(message,"__esModule",{value:!0}),message.Message=void 0;class Message{static LexerTokenError(e){let t=0,r,n=e.peek(t).value,i=0;const{line:l,column:c,index:b}=e.state;for(;(r=e.peek(--t))&&(r.value==`
`&&(i++,n=`${l+2-i} ${n}`),n=r.value+n,!(i>=2)););n=`${l+2-(i+1)} ${n}`;const s=n.lastIndexOf(`
`),f=n.length-s;return n+=`
`+"^".padStart(f-1),typeof c!="undefined"&&typeof l!="undefined"?`Syntax error at line ${l+1} col ${c+1}:

${n}
`:`Syntax error at index ${b}:

${n}
`}static GetSymbolDisplay(e,t,r){if(typeof e=="string")return e;if("literal"in e)return JSON.stringify(e.literal);if(e instanceof RegExp)return t?e.toString():`character matching ${e.toString()}`;if("type"in e)return t?`%${e.type}`:`${e.type} token`;if("test"in e)return t?`<${e.test.toString()}>`:`token matching ${e.test.toString()}`;if(r)throw new Error("Unknown symbol type: "+JSON.stringify(e))}}message.Message=Message,Object.defineProperty(errorReporting$1,"__esModule",{value:!0}),errorReporting$1.ParserErrorService=void 0;const message_1$1=message;class ParserErrorService$1{constructor(e){this.parser=e}lexerError(e){let t,r;const n=e.token;return n?(t="input "+JSON.stringify(n.text[0])+" (lexer error)",r=message_1$1.Message.LexerTokenError(this.parser.lexer)):(t="input (lexer error)",r=e.message),this.reportErrorCommon(r,t)}tokenError(e){const t=(e.type?e.type+" token: ":"")+JSON.stringify(e.value!==void 0?e.value:e),r=message_1$1.Message.LexerTokenError(this.parser.lexer),n=new Error(this.reportErrorCommon(r,t));return n.offset=this.parser.current,n.token=e,n}displayStateStack(e,t){let r,n=0;for(let i=0;i<e.length;i++){const l=e[i],c=this.formatRule(l.rule,l.dot);c===r?n++:(n>0&&t.push("    ^ "+n+" more lines identical to this"),n=0,t.push("    "+c)),r=c}}reportErrorCommon(e,t){const r=[];r.push(e);const n=this.parser.table.length-2,i=this.parser.table[n],l=i.states.filter(c=>{const b=c.rule.symbols[c.dot];return b&&typeof b!="string"});return l.length===0?(r.push("Unexpected "+t+`. I did not expect any more input. Here is the state of my parse table:
`),this.displayStateStack(i.states,r)):(r.push("Unexpected "+t+`. Instead, I was expecting to see one of the following:
`),l.map(b=>this.buildFirstStateStack(b,new Set)||[b]).forEach(b=>{const s=b[0],f=s.rule.symbols[s.dot],m=message_1$1.Message.GetSymbolDisplay(f,!1,!0);r.push("A "+m+" based on:"),this.displayStateStack(b,r)})),r.push(""),r.join(`
`)}buildFirstStateStack(e,t){if(t.has(e))return null;if(e.wantedBy.length===0)return[e];const r=e.wantedBy[0],n=new Set(t);n.add(e);const i=this.buildFirstStateStack(r,n);return i===null?null:[e].concat(i)}formatRule(e,t){let r=e.symbols.slice(0,t).map(n=>message_1$1.Message.GetSymbolDisplay(n,!0,!0)).join(" ");return typeof t!="undefined"&&(r+=" \u25CF "+e.symbols.slice(t).map(n=>message_1$1.Message.GetSymbolDisplay(n,!0,!0)).join(" ")),e.name+" \u2192 "+r}}errorReporting$1.ParserErrorService=ParserErrorService$1;var legacyAdapter={};Object.defineProperty(legacyAdapter,"__esModule",{value:!0}),legacyAdapter.LegacyLexerAdapter=void 0;class LegacyLexerAdapter{constructor(e){this.lexer=e,this.history=[],this.queue="",this.$indexOffset=0,this.$index=-1}get index(){var e;return((e=this.active)===null||e===void 0?void 0:e.state.index)||0}get line(){var e;return((e=this.active)===null||e===void 0?void 0:e.state.line)||0}get current(){var e;return(e=this.active)===null||e===void 0?void 0:e.token}get column(){var e;return((e=this.active)===null||e===void 0?void 0:e.state.column)||0}get active(){return this.history[this.$index]}get state(){return{index:this.index-this.$indexOffset,indexOffset:this.$indexOffset,line:this.line,lineOffset:0,column:this.column}}reset(e){this.lexer.reset(e),this.history=[],this.$index=-1,this.$indexOffset=0}restore(e){const t=e.index+e.indexOffset;t<this.history[0].state.index||(this.$index+=t-this.active.state.index)}feed(e,t){this.queue+=e,t&&this.flush()}flush(){this.history=this.history.slice(this.$index),this.$indexOffset+=this.$index,this.$index=0}previous(){if(this.$index>0){const{token:e}=this.history[--this.$index];return e}}next(){if(this.$index+1>=this.history.length&&this.lexerNext(),this.$index+1<this.history.length)return this.history[++this.$index].token}peek(e){for(e+=this.$index;e>=this.history.length&&this.lexerNext(););if(e>=0&&e<this.history.length)return this.history[e].token}lexerNext(){let e=this.lexer.next();if(typeof e=="undefined"&&(this.queue&&(this.lexer.reset(this.queue,this.lexer.save()),this.queue="",e=this.lexer.next()),!e))return;const{state:t}=this.history[this.history.length-1]||{state:{index:-1}};return this.history.push({token:e,state:{lineOffset:0,indexOffset:this.$indexOffset,line:e.line-1,column:e.col-1,index:t.index+1}}),e}}legacyAdapter.LegacyLexerAdapter=LegacyLexerAdapter;var basicLexer={};Object.defineProperty(basicLexer,"__esModule",{value:!0}),basicLexer.BasicLexer=void 0;class BasicLexer{constructor(){this.buffer="",this.$indexOffset=0,this.$index=-1,this.$lineOffset=0,this.$line=0,this.$newLine=0,this.$prevNewLine=0}get index(){return this.$index+this.$indexOffset}get line(){return this.$line+this.$lineOffset}get current(){return{value:this.buffer[this.$index]}}get column(){if(this.$index==this.$newLine)return this.$index-this.$prevNewLine;const e=this.line>0?-1:0;return this.$index-this.$newLine+e}get state(){return{index:this.$index,indexOffset:this.$indexOffset,line:this.$line,lineOffset:this.$lineOffset,column:this.column}}reset(e){this.buffer=e,this.$index=-1,this.$indexOffset=0,this.$line=0,this.$lineOffset=0,this.$prevNewLine=0,this.$newLine=0}restore(e){if(this.$indexOffset=e.indexOffset||0,this.$index=typeof e.index=="number"?e.index:-1,this.$lineOffset=e.lineOffset||0,this.$line=e.line||0,this.$line){const t=e.column||0;this.$newLine=this.$index-(t+1),this.$prevNewLine=this.$index-(t+1)}else this.$newLine=0,this.$prevNewLine=0}feed(e,t){Array.isArray(e)&&(!this.buffer||Array.isArray(this.buffer))?(this.buffer=Array.isArray(this.buffer)?this.buffer:[],this.buffer.push(...e)):Array.isArray(this.buffer)?this.buffer.push(e):this.buffer=this.buffer+e,t&&this.flush()}flush(){this.buffer=this.buffer.slice(this.$index),this.$indexOffset+=this.$index,this.$lineOffset+=this.$line,this.$newLine-=this.$index,this.$prevNewLine-=this.$index,this.$index=0,this.$line=0}previous(){if(this.$index>0){const e=this.buffer[--this.$index];return e===`
`&&(this.$line--,this.$newLine=this.$index,this.$prevNewLine=this.buffer.lastIndexOf(`
`,this.$newLine),this.$prevNewLine=this.$prevNewLine>0&&this.$prevNewLine==this.$newLine?0:this.$newLine),{value:e}}}next(){if(this.$index+1<this.buffer.length){const e=this.buffer[++this.$index];return e===`
`&&(this.$line++,this.$prevNewLine=this.$newLine,this.$newLine=this.$index),{value:e}}}peek(e){if(e+=this.$index,e>=0&&e<this.buffer.length)return{value:this.buffer[e]}}}basicLexer.BasicLexer=BasicLexer,Object.defineProperty(parser$1,"__esModule",{value:!0}),parser$1.NearleyParser=void 0;const column_1$1=column$1,error_reporting_1$1=errorReporting$1,legacy_adapter_1$1=legacyAdapter,basic_lexer_1$1=basicLexer;class NearleyParser{constructor({rules:e,start:t,lexer:r,map:n},i={}){if(this.keepHistory=!1,this.current=0,this.ruleMap=Object.create(null),this.rules=e,this.start=t||this.rules[0].name,this.lexer=r,!n)for(const c of e)this.ruleMap[c.name]?this.ruleMap[c.name].push(c):this.ruleMap[c.name]=[c];this.keepHistory=!!(i!=null&&i.keepHistory),this.errorService=new error_reporting_1$1.ParserErrorService(this),this.lexer=(i==null?void 0:i.lexer)||this.lexer||new basic_lexer_1$1.BasicLexer,this.lexer.restore||(this.lexer=new legacy_adapter_1$1.LegacyLexerAdapter(this.lexer));const l=new column_1$1.Column(this.ruleMap,0);this.table=[l],l.wants[this.start]=[],l.predict(this.start),l.process()}next(){try{return this.lexer.next()}catch(e){const t=new column_1$1.Column(this.ruleMap,this.current+1);throw this.table.push(t),this.errorService.lexerError(e)}}feed(e){this.lexer.feed(e);let t,r;for(;t=this.next();){r=this.table[this.current],this.keepHistory||delete this.table[this.current-1];const n=this.current+1,i=new column_1$1.Column(this.ruleMap,n);this.table.push(i);const l=t.text!==void 0?t.text:t.value,c=this.lexer.constructor===basic_lexer_1$1.BasicLexer?t.value:t,{scannable:b}=r;for(let s=b.length;s--;){const f=b[s],m=f.rule.symbols[f.dot];if(m.test&&m.test(c)||m.type&&m.type===t.type||(m==null?void 0:m.literal)===l){const S=f.nextState({data:c,token:t,isToken:!0,reference:n-1});i.states.push(S)}}if(i.process(),i.states.length===0)throw this.errorService.tokenError(t);this.keepHistory&&(r.lexerState=this.lexer.state),this.current++}r&&(this.lexerState=this.lexer.state),this.results=this.finish()}save(){const e=this.table[this.current];return e.lexerState=this.lexerState,e}restore(e){const t=e.index;this.current=t,this.table[t]=e,this.table.splice(t+1),this.lexerState=e.lexerState,this.lexer.restore(e.lexerState),this.results=this.finish()}rewind(e){if(!this.keepHistory)throw new Error("set option `keepHistory` to enable rewinding");this.restore(this.table[e])}finish(){const e=[],{states:t}=this.table[this.table.length-1];for(const{rule:{name:r,symbols:n},dot:i,reference:l,data:c}of t)r===this.start&&i===n.length&&!l&&c!==NearleyParser.fail&&e.push(c);return e}}parser$1.NearleyParser=NearleyParser,NearleyParser.fail=Symbol();var parser={},column={},state={};Object.defineProperty(state,"__esModule",{value:!0}),state.State=void 0;const parser_1$3=parser;class State{constructor(e,t,r,n){this.rule=e,this.dot=t,this.reference=r,this.wantedBy=n,this.data=[],this.isComplete=this.dot===e.symbols.length}nextState(e){const t=new State(this.rule,this.dot+1,this.reference,this.wantedBy);return t.left=this,t.right=e,t.isComplete&&(t.data=t.build(),t.right=void 0),t}build(){const e=[];let t=this;do e.push(t.right.data),t=t.left;while(t.left);return e.reverse(),e}finish(){this.rule.transform?this.data=this.rule.transform({data:this.data,reference:this.reference,dot:this.dot,name:this.rule.name,reject:parser_1$3.EarleyParser.fail}):this.rule.postprocess&&(this.data=this.rule.postprocess(this.data,this.reference,parser_1$3.EarleyParser.fail))}}state.State=State,Object.defineProperty(column,"__esModule",{value:!0}),column.Column=void 0;const parser_1$2=parser,state_1=state;class Column{constructor(e,t){this.ruleMap=e,this.index=t,this.states=[],this.wants=Object.create(null),this.scannable=[],this.completed=Object.create(null)}process(e){let t=0,r;for(;r=this.states[t++];)if(r.isComplete){if(r.finish(),r.data!==parser_1$2.EarleyParser.fail){const{wantedBy:n}=r;for(let i=n.length;i--;)this.complete(n[i],r);if(r.reference===this.index){const{name:i}=r.rule;this.completed[i]=this.completed[i]||[],this.completed[i].push(r)}}}else{const n=r.rule.symbols[r.dot];if(typeof n!="string"){this.scannable.push(r);continue}if(this.wants[n]){if(this.wants[n].push(r),this.completed[n])for(const i of this.completed[n])this.complete(r,i)}else this.wants[n]=[r],this.predict(n)}}predict(e){if(!!this.ruleMap[e])for(const t of this.ruleMap[e])this.states.push(new state_1.State(t,0,this.index,this.wants[e]))}complete(e,t){const r=e.nextState(t);this.states.push(r)}}column.Column=Column;var errorReporting={};Object.defineProperty(errorReporting,"__esModule",{value:!0}),errorReporting.ParserErrorService=void 0;const message_1=message;class ParserErrorService{constructor(e){this.parser=e}lexerError(e){let t,r;const n=e.token;return n?(t="input "+JSON.stringify(n.text[0])+" (lexer error)",r=message_1.Message.LexerTokenError(this.parser.lexer)):(t="input (lexer error)",r=e.message),this.reportErrorCommon(r,t)}tokenError(e){const t=(e.type?e.type+" token: ":"")+JSON.stringify(e.value!==void 0?e.value:e),r=message_1.Message.LexerTokenError(this.parser.lexer),n=new Error(this.reportErrorCommon(r,t));return n.offset=this.parser.current,n.token=e,n}displayStateStack(e,t){let r,n=0;for(let i=0;i<e.length;i++){const l=e[i],c=this.formatRule(l.rule,l.dot);c===r?n++:(n>0&&t.push("    ^ "+n+" more lines identical to this"),n=0,t.push("    "+c)),r=c}}reportErrorCommon(e,t){const r=[];r.push(e);const n=this.parser.table.length-2,i=this.parser.table[n],l=i.states.filter(c=>{const b=c.rule.symbols[c.dot];return b&&typeof b!="string"});return l.length===0?(r.push("Unexpected "+t+`. I did not expect any more input. Here is the state of my parse table:
`),this.displayStateStack(i.states,r)):(r.push("Unexpected "+t+`. Instead, I was expecting to see one of the following:
`),l.map(b=>this.buildFirstStateStack(b,new Set)||[b]).forEach(b=>{const s=b[0],f=s.rule.symbols[s.dot],m=message_1.Message.GetSymbolDisplay(f,!1,!0);r.push("A "+m+" based on:"),this.displayStateStack(b,r)})),r.push(""),r.join(`
`)}buildFirstStateStack(e,t){if(t.has(e))return null;if(e.wantedBy.length===0)return[e];const r=e.wantedBy[0],n=new Set(t);n.add(e);const i=this.buildFirstStateStack(r,n);return i===null?null:[e].concat(i)}formatRule(e,t){let r=e.symbols.slice(0,t).map(n=>message_1.Message.GetSymbolDisplay(n,!0,!0)).join(" ");return typeof t!="undefined"&&(r+=" \u25CF "+e.symbols.slice(t).map(n=>message_1.Message.GetSymbolDisplay(n,!0,!0)).join(" ")),e.name+" \u2192 "+r}}errorReporting.ParserErrorService=ParserErrorService,Object.defineProperty(parser,"__esModule",{value:!0}),parser.EarleyParser=void 0;const column_1=column,error_reporting_1=errorReporting,legacy_adapter_1=legacyAdapter,basic_lexer_1=basicLexer;class EarleyParser{constructor({rules:e,start:t,lexer:r,map:n},i={}){if(this.keepHistory=!1,this.current=0,this.ruleMap=Object.create(null),this.rules=e,this.start=t||this.rules[0].name,this.lexer=r,!n)for(const c of e)this.ruleMap[c.name]?this.ruleMap[c.name].push(c):this.ruleMap[c.name]=[c];this.keepHistory=!!(i!=null&&i.keepHistory),this.errorService=new error_reporting_1.ParserErrorService(this),this.lexer=(i==null?void 0:i.lexer)||this.lexer||new basic_lexer_1.BasicLexer,this.lexer.restore||(this.lexer=new legacy_adapter_1.LegacyLexerAdapter(this.lexer));const l=new column_1.Column(this.ruleMap,0);this.table=[l],l.wants[this.start]=[],l.predict(this.start),l.process()}next(){try{return this.lexer.next()}catch(e){const t=new column_1.Column(this.ruleMap,this.current+1);throw this.table.push(t),this.errorService.lexerError(e)}}feed(e){this.lexer.feed(e);let t,r;for(;t=this.next();){r=this.table[this.current],this.keepHistory||delete this.table[this.current-1];const n=this.current+1,i=new column_1.Column(this.ruleMap,n);this.table.push(i);const l=t.text!==void 0?t.text:t.value,c=this.lexer.constructor===basic_lexer_1.BasicLexer?t.value:t,{scannable:b}=r;for(let s=b.length;s--;){const f=b[s],m=f.rule.symbols[f.dot];if(m.test&&m.test(c)||m.type&&m.type===t.type||(m==null?void 0:m.literal)===l){const S=f.nextState({data:c,token:t,isToken:!0,reference:n-1});i.states.push(S)}}if(i.process(),i.states.length===0)throw this.errorService.tokenError(t);this.keepHistory&&(r.lexerState=this.lexer.state),this.current++}r&&(this.lexerState=this.lexer.state),this.results=this.finish()}save(){const e=this.table[this.current];return e.lexerState=this.lexerState,e}restore(e){const t=e.index;this.current=t,this.table[t]=e,this.table.splice(t+1),this.lexerState=e.lexerState,this.lexer.restore(e.lexerState),this.results=this.finish()}rewind(e){if(!this.keepHistory)throw new Error("set option `keepHistory` to enable rewinding");this.restore(this.table[e])}finish(){const e=[],{states:t}=this.table[this.table.length-1];for(const{rule:{name:r,symbols:n},dot:i,reference:l,data:c}of t)r===this.start&&i===n.length&&!l&&c!==EarleyParser.fail&&e.push(c);return e}}parser.EarleyParser=EarleyParser,EarleyParser.fail=Symbol(),Object.defineProperty(parser$2,"__esModule",{value:!0}),parser$2.Parser=parser$2.Parse=void 0;const parser_1$1=parser$1,parser_2=parser,ParserRegistry={nearley:parser_1$1.NearleyParser,earley:parser_2.EarleyParser};function Parse(a,e,t){return new Parser(a,t).run(e)}parser$2.Parse=Parse;class Parser{constructor(e,t={algorithm:"nearley"}){this.grammar=e,this.options=t,this.parserClass=ParserRegistry[t.algorithm],this.parser=new this.parserClass(this.grammar,t)}get results(){return this.parser.results}feed(e){return this.parser.feed(e),this.results}run(e){const t=new this.parserClass(this.grammar,this.options);return t.feed(e),t.results[0]}}parser$2.Parser=Parser;const grammar$5={rules:[{name:"cow$string$1",symbols:[{literal:"M"},{literal:"O"}],postprocess:{builtin:"joiner"}},{name:"cow$ebnf$1",symbols:[{literal:"O"}]},{name:"cow$ebnf$1",symbols:["cow$ebnf$1",{literal:"O"}],postprocess:{builtin:"arrpush"}},{name:"cow",symbols:["cow$string$1","cow$ebnf$1"]}],body:[],customTokens:[],config:{},macros:{},start:"cow",version:"unknown"},exportName$5="grammar";var require$$1={grammar:grammar$5,exportName:exportName$5};const grammar$4={rules:[{name:"unsigned_int$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"unsigned_int$ebnf$1",symbols:["unsigned_int$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"unsigned_int",symbols:["unsigned_int$ebnf$1"],postprocess:`
    function(d) {
        return parseInt(d[0].join(""));
    }
`},{name:"int$ebnf$1$subexpression$1",symbols:[{literal:"-"}]},{name:"int$ebnf$1$subexpression$1",symbols:[{literal:"+"}]},{name:"int$ebnf$1",symbols:["int$ebnf$1$subexpression$1"],postprocess:{builtin:"id"}},{name:"int$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"int$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"int$ebnf$2",symbols:["int$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"int",symbols:["int$ebnf$1","int$ebnf$2"],postprocess:`
    function(d) {
        if (d[0]) {
            return parseInt(d[0][0]+d[1].join(""));
        } else {
            return parseInt(d[1].join(""));
        }
    }
`},{name:"unsigned_decimal$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"unsigned_decimal$ebnf$1",symbols:["unsigned_decimal$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",symbols:["unsigned_decimal$ebnf$2$subexpression$1$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"unsigned_decimal$ebnf$2$subexpression$1",symbols:[{literal:"."},"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1"]},{name:"unsigned_decimal$ebnf$2",symbols:["unsigned_decimal$ebnf$2$subexpression$1"],postprocess:{builtin:"id"}},{name:"unsigned_decimal$ebnf$2",symbols:[],postprocess:{builtin:"nuller"}},{name:"unsigned_decimal",symbols:["unsigned_decimal$ebnf$1","unsigned_decimal$ebnf$2"],postprocess:`
    function(d) {
        return parseFloat(
            d[0].join("") +
            (d[1] ? "."+d[1][1].join("") : "")
        );
    }
`},{name:"decimal$ebnf$1",symbols:[{literal:"-"}],postprocess:{builtin:"id"}},{name:"decimal$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"decimal$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"decimal$ebnf$2",symbols:["decimal$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"decimal$ebnf$3$subexpression$1$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"decimal$ebnf$3$subexpression$1$ebnf$1",symbols:["decimal$ebnf$3$subexpression$1$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"decimal$ebnf$3$subexpression$1",symbols:[{literal:"."},"decimal$ebnf$3$subexpression$1$ebnf$1"]},{name:"decimal$ebnf$3",symbols:["decimal$ebnf$3$subexpression$1"],postprocess:{builtin:"id"}},{name:"decimal$ebnf$3",symbols:[],postprocess:{builtin:"nuller"}},{name:"decimal",symbols:["decimal$ebnf$1","decimal$ebnf$2","decimal$ebnf$3"],postprocess:`
    function(d) {
        return parseFloat(
            (d[0] || "") +
            d[1].join("") +
            (d[2] ? "."+d[2][1].join("") : "")
        );
    }
`},{name:"percentage",symbols:["decimal",{literal:"%"}],postprocess:`
    function(d) {
        return d[0]/100;
    }
`},{name:"jsonfloat$ebnf$1",symbols:[{literal:"-"}],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"jsonfloat$ebnf$2",symbols:["jsonfloat$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"jsonfloat$ebnf$3$subexpression$1$ebnf$1",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"jsonfloat$ebnf$3$subexpression$1$ebnf$1",symbols:["jsonfloat$ebnf$3$subexpression$1$ebnf$1",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"jsonfloat$ebnf$3$subexpression$1",symbols:[{literal:"."},"jsonfloat$ebnf$3$subexpression$1$ebnf$1"]},{name:"jsonfloat$ebnf$3",symbols:["jsonfloat$ebnf$3$subexpression$1"],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$3",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$1",symbols:[{regex:{source:"[+-]",flags:""}}],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$2",symbols:[{regex:{source:"[0-9]",flags:""}}]},{name:"jsonfloat$ebnf$4$subexpression$1$ebnf$2",symbols:["jsonfloat$ebnf$4$subexpression$1$ebnf$2",{regex:{source:"[0-9]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"jsonfloat$ebnf$4$subexpression$1",symbols:[{regex:{source:"[eE]",flags:""}},"jsonfloat$ebnf$4$subexpression$1$ebnf$1","jsonfloat$ebnf$4$subexpression$1$ebnf$2"]},{name:"jsonfloat$ebnf$4",symbols:["jsonfloat$ebnf$4$subexpression$1"],postprocess:{builtin:"id"}},{name:"jsonfloat$ebnf$4",symbols:[],postprocess:{builtin:"nuller"}},{name:"jsonfloat",symbols:["jsonfloat$ebnf$1","jsonfloat$ebnf$2","jsonfloat$ebnf$3","jsonfloat$ebnf$4"],postprocess:`
    function(d) {
        return parseFloat(
            (d[0] || "") +
            d[1].join("") +
            (d[2] ? "."+d[2][1].join("") : "") +
            (d[3] ? "e" + (d[3][1] || "+") + d[3][2].join("") : "")
        );
    }
`}],body:[],customTokens:[],config:{},macros:{},start:"unsigned_int",version:"unknown"},exportName$4="grammar";var require$$2={grammar:grammar$4,exportName:exportName$4};const grammar$3={rules:[],body:[`
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function nth(n) {
    return function(d) {
        return d[n];
    };
}
`,`
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function $(o) {
    return function(d) {
        var ret = {};
        Object.keys(o).forEach(function(k) {
            ret[k] = d[o[k]];
        });
        return ret;
    };
}
`],customTokens:[],config:{},macros:{delimited:{args:["el","delim"],exprs:[{tokens:[{mixin:"el"},{ebnf:{subexpression:[{tokens:[{mixin:"delim"},{mixin:"el"}],postprocess:" nth(1) "}]},modifier:":*"}],postprocess:`
    function(d) {
        return [d[0]].concat(d[1]);
    }
`}]}},start:"",version:"unknown"},exportName$3="grammar";var require$$3={grammar:grammar$3,exportName:exportName$3};const grammar$2={rules:[{name:"final$ebnf$1",symbols:[{token:'(lexer.has("ws") ? {type: "ws"} : ws)'}],postprocess:{builtin:"id"}},{name:"final$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:" function(d) { return d[1]; } "},{name:"prog",symbols:["prod"],postprocess:" function(d) { return [d[0]]; } "},{name:"prog",symbols:["prod","ws","prog"],postprocess:" function(d) { return [d[0]].concat(d[2]); } "},{name:"prod",symbols:["word","_",{token:'(lexer.has("arrow") ? {type: "arrow"} : arrow)'},"_","expression+"],postprocess:" function(d) { return {name: d[0], rules: d[4]}; } "},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",{token:'(lexer.has("arrow") ? {type: "arrow"} : arrow)'},"_","expression+"],postprocess:" function(d) {return {macro: d[0], args: d[3], exprs: d[9]}} "},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:" function(d) { return {body: d[2]}; } "},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:" function(d) { return {config: d[1], value: d[3]}; } "},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:" function(d) {return {include: d[2].literal, builtin: false}} "},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:" function(d) {return {include: d[2].literal, builtin: true }} "},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:" function(d) { return d[0].concat([d[4]]); } "},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:" function(d) { return d[0].concat([d[4]]); } "},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:" function(d) { return d[0].concat([d[4]]); } "},{name:"completeexpression",symbols:["expr"],postprocess:" function(d) { return {tokens: d[0]}; } "},{name:"completeexpression",symbols:["expr","_","js"],postprocess:" function(d) { return {tokens: d[0], postprocess: d[2]}; } "},{name:"expr_member",symbols:["word"],postprocess:" id "},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:" function(d) {return {mixin: d[1]}} "},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:" function(d) {return {macrocall: d[0], args: d[3]}} "},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:{builtin:"id"}},{name:"expr_member$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:" function(d) { if (d[1]) {return insensitive(d[0]); } else {return d[0]; } } "},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:" function(d) {return {token: d[1]}} "},{name:"expr_member",symbols:["charclass"],postprocess:" id "},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:" function(d) {return {'subexpression': d[2]} ;} "},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:" function(d) {return {'ebnf': d[0], 'modifier': d[2]}; } "},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:" getValue "},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:" getValue "},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:" getValue "},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:" function(d){ return d[0].concat([d[2]]); } "},{name:"word",symbols:[{token:'(lexer.has("word") ? {type: "word"} : word)'}],postprocess:" getValue "},{name:"string",symbols:[{token:'(lexer.has("string") ? {type: "string"} : string)'}],postprocess:" d => ({literal: d[0].value}) "},{name:"string",symbols:[{token:'(lexer.has("btstring") ? {type: "btstring"} : btstring)'}],postprocess:" d => ({literal: d[0].value}) "},{name:"charclass",symbols:[{token:'(lexer.has("charclass") ? {type: "charclass"} : charclass)'}],postprocess:" getValue "},{name:"js",symbols:[{token:'(lexer.has("js") ? {type: "js"} : js)'}],postprocess:" getValue "},{name:"_$ebnf$1",symbols:["ws"],postprocess:{builtin:"id"}},{name:"_$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[{token:'(lexer.has("ws") ? {type: "ws"} : ws)'}]},{name:"ws$ebnf$1",symbols:[{token:'(lexer.has("ws") ? {type: "ws"} : ws)'}],postprocess:{builtin:"id"}},{name:"ws$ebnf$1",symbols:[],postprocess:{builtin:"nuller"}},{name:"ws",symbols:["ws$ebnf$1",{token:'(lexer.has("comment") ? {type: "comment"} : comment)'},"_"]}],body:[`
function getValue(d) {
    return d[0].value
}

function literals(list) {
    var rules = {}
    for (var lit of list) {
        rules[lit] = {match: lit, next: 'main'}
    }
    return rules
}

var moo = require('moo')
var rules = Object.assign({
    ws: {match: /\\s+/, lineBreaks: true, next: 'main'},
    comment: /\\#.*/,
    arrow: {match: /[=-]+\\>/, next: 'main'},
    js: {
        match: /\\{\\%(?:[^%]|\\%[^}])*\\%\\}/,
        value: x => x.slice(2, -2),
        lineBreaks: true,
    },
    word: {match: /[\\w\\?\\+]+/, next: 'afterWord'},
    string: {
        match: /"(?:[^\\\\"\\n]|\\\\["\\\\/bfnrt]|\\\\u[a-fA-F0-9]{4})*"/,
        value: x => JSON.parse(x),
        next: 'main',
    },
    btstring: {
        match: /\`[^\`]*\`/,
        value: x => x.slice(1, -1),
        next: 'main',
        lineBreaks: true,
    },
}, literals([
    ",", "|", "$", "%", "(", ")",
    ":?", ":*", ":+",
    "@include", "@builtin", "@",
    "]",
]))

var lexer = moo.states({
    main: Object.assign({}, rules, {
        charclass: {
            match: /\\.|\\[(?:\\\\.|[^\\\\\\n])+?\\]/,
            value: x => new RegExp(x),
        },
    }),
    // Both macro arguments and charclasses are both enclosed in [ ].
    // We disambiguate based on whether the previous token was a \`word\`.
    afterWord: Object.assign({}, rules, {
        "[": {match: "[", next: 'main'},
    }),
})

function insensitive(sl) {
    var s = sl.literal;
    var result = [];
    for (var i=0; i<s.length; i++) {
        var c = s.charAt(i);
        if (c.toUpperCase() !== c || c.toLowerCase() !== c) {
            result.push(new RegExp("[" + c.toLowerCase() + c.toUpperCase() + "]"));
            } else {
            result.push({literal: c});
        }
    }
    return {subexpression: [{tokens: result, postprocess: function(d) {return d.join(""); }}]};
}

`],customTokens:["ws","arrow","word","string","btstring","charclass","js","comment"],config:{lexer:"lexer"},macros:{},start:"final",version:"unknown"},exportName$2="grammar";var require$$4={grammar:grammar$2,exportName:exportName$2};const grammar$1={rules:[{name:"dqstring$ebnf$1",symbols:[]},{name:"dqstring$ebnf$1",symbols:["dqstring$ebnf$1","dstrchar"],postprocess:{builtin:"arrpush"}},{name:"dqstring",symbols:[{literal:'"'},"dqstring$ebnf$1",{literal:'"'}],postprocess:' function(d) {return d[1].join(""); } '},{name:"sqstring$ebnf$1",symbols:[]},{name:"sqstring$ebnf$1",symbols:["sqstring$ebnf$1","sstrchar"],postprocess:{builtin:"arrpush"}},{name:"sqstring",symbols:[{literal:"'"},"sqstring$ebnf$1",{literal:"'"}],postprocess:' function(d) {return d[1].join(""); } '},{name:"btstring$ebnf$1",symbols:[]},{name:"btstring$ebnf$1",symbols:["btstring$ebnf$1",{regex:{source:"[^`]",flags:""}}],postprocess:{builtin:"arrpush"}},{name:"btstring",symbols:[{literal:"`"},"btstring$ebnf$1",{literal:"`"}],postprocess:' function(d) {return d[1].join(""); } '},{name:"dstrchar",symbols:[{regex:{source:'[^\\\\"\\n]',flags:""}}],postprocess:" id "},{name:"dstrchar",symbols:[{literal:"\\"},"strescape"],postprocess:`
    function(d) {
        return JSON.parse("\\""+d.join("")+"\\"");
    }
`},{name:"sstrchar",symbols:[{regex:{source:"[^\\\\'\\n]",flags:""}}],postprocess:" id "},{name:"sstrchar",symbols:[{literal:"\\"},"strescape"],postprocess:' function(d) { return JSON.parse("\\""+d.join("")+"\\""); } '},{name:"sstrchar$string$1",symbols:[{literal:"\\"},{literal:"'"}],postprocess:{builtin:"joiner"}},{name:"sstrchar",symbols:["sstrchar$string$1"],postprocess:` function(d) {return "'"; } `},{name:"strescape",symbols:[{regex:{source:'["\\\\/bfnrt]',flags:""}}],postprocess:" id "},{name:"strescape",symbols:[{literal:"u"},{regex:{source:"[a-fA-F0-9]",flags:""}},{regex:{source:"[a-fA-F0-9]",flags:""}},{regex:{source:"[a-fA-F0-9]",flags:""}},{regex:{source:"[a-fA-F0-9]",flags:""}}],postprocess:`
    function(d) {
        return d.join("");
    }
`}],body:[],customTokens:[],config:{},macros:{},start:"dqstring",version:"unknown"},exportName$1="grammar";var require$$5={grammar:grammar$1,exportName:exportName$1};const grammar={rules:[{name:"_$ebnf$1",symbols:[]},{name:"_$ebnf$1",symbols:["_$ebnf$1","wschar"],postprocess:{builtin:"arrpush"}},{name:"_",symbols:["_$ebnf$1"],postprocess:" function(d) {return null;} "},{name:"__$ebnf$1",symbols:["wschar"]},{name:"__$ebnf$1",symbols:["__$ebnf$1","wschar"],postprocess:{builtin:"arrpush"}},{name:"__",symbols:["__$ebnf$1"],postprocess:" function(d) {return null;} "},{name:"wschar",symbols:[{regex:{source:"[ \\t\\n\\v\\f]",flags:""}}],postprocess:" id "}],body:[],customTokens:[],config:{},macros:{},start:"_",version:"unknown"},exportName="grammar";var require$$6={grammar,exportName},nearley$1={exports:{}},moo={exports:{}};(function(a){(function(e,t){a.exports?a.exports=t():e.moo=t()})(commonjsGlobal,function(){var e=Object.prototype.hasOwnProperty,t=Object.prototype.toString,r=typeof new RegExp().sticky=="boolean";function n(o){return o&&t.call(o)==="[object RegExp]"}function i(o){return o&&typeof o=="object"&&!n(o)&&!Array.isArray(o)}function l(o){return o.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function c(o){var u=new RegExp("|"+o);return u.exec("").length-1}function b(o){return"("+o+")"}function s(o){if(!o.length)return"(?!)";var u=o.map(function(p){return"(?:"+p+")"}).join("|");return"(?:"+u+")"}function f(o){if(typeof o=="string")return"(?:"+l(o)+")";if(n(o)){if(o.ignoreCase)throw new Error("RegExp /i flag not allowed");if(o.global)throw new Error("RegExp /g flag is implied");if(o.sticky)throw new Error("RegExp /y flag is implied");if(o.multiline)throw new Error("RegExp /m flag is implied");return o.source}else throw new Error("Not a pattern: "+o)}function m(o){for(var u=Object.getOwnPropertyNames(o),p=[],h=0;h<u.length;h++){var $=u[h],y=o[$],g=[].concat(y);if($==="include"){for(var x=0;x<g.length;x++)p.push({include:g[x]});continue}var v=[];g.forEach(function(d){i(d)?(v.length&&p.push(O($,v)),p.push(O($,d)),v=[]):v.push(d)}),v.length&&p.push(O($,v))}return p}function S(o){for(var u=[],p=0;p<o.length;p++){var h=o[p];if(h.include){for(var $=[].concat(h.include),y=0;y<$.length;y++)u.push({include:$[y]});continue}if(!h.type)throw new Error("Rule has no type: "+JSON.stringify(h));u.push(O(h.type,h))}return u}function O(o,u){if(i(u)||(u={match:u}),u.include)throw new Error("Matching rules cannot also include states");var p={defaultType:o,lineBreaks:!!u.error||!!u.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var h in u)e.call(u,h)&&(p[h]=u[h]);if(typeof p.type=="string"&&o!==p.type)throw new Error("Type transform cannot be a string (type '"+p.type+"' for token '"+o+"')");var $=p.match;return p.match=Array.isArray($)?$:$?[$]:[],p.match.sort(function(y,g){return n(y)&&n(g)?0:n(g)?-1:n(y)?1:g.length-y.length}),p}function C(o){return Array.isArray(o)?S(o):m(o)}var q=O("error",{lineBreaks:!0,shouldThrow:!0});function A(o,u){for(var p=null,h=Object.create(null),$=!0,y=null,g=[],x=[],v=0;v<o.length;v++)o[v].fallback&&($=!1);for(var v=0;v<o.length;v++){var d=o[v];if(d.include)throw new Error("Inheritance is not allowed in stateless lexers");if(d.error||d.fallback){if(p)throw!d.fallback==!p.fallback?new Error("Multiple "+(d.fallback?"fallback":"error")+" rules not allowed (for token '"+d.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+d.defaultType+"')");p=d}var w=d.match.slice();if($)for(;w.length&&typeof w[0]=="string"&&w[0].length===1;){var R=w.shift();h[R.charCodeAt(0)]=d}if(d.pop||d.push||d.next){if(!u)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+d.defaultType+"')");if(d.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+d.defaultType+"')")}if(w.length!==0){$=!1,g.push(d);for(var _=0;_<w.length;_++){var E=w[_];if(!!n(E)){if(y===null)y=E.unicode;else if(y!==E.unicode&&d.fallback===!1)throw new Error("If one rule is /u then all must be")}}var N=s(w.map(f)),k=new RegExp(N);if(k.test(""))throw new Error("RegExp matches empty string: "+k);var M=c(N);if(M>0)throw new Error("RegExp has capture groups: "+k+`
Use (?: \u2026 ) instead`);if(!d.lineBreaks&&k.test(`
`))throw new Error("Rule should declare lineBreaks: "+k);x.push(b(N))}}var P=p&&p.fallback,T=r&&!P?"ym":"gm",L=r||P?"":"|";y===!0&&(T+="u");var D=new RegExp(s(x)+L,T);return{regexp:D,groups:g,fast:h,error:p||q}}function G(o){var u=A(C(o));return new j({start:u},"start")}function F(o,u,p){var h=o&&(o.push||o.next);if(h&&!p[h])throw new Error("Missing state '"+h+"' (in token '"+o.defaultType+"' of state '"+u+"')");if(o&&o.pop&&+o.pop!=1)throw new Error("pop must be 1 (in token '"+o.defaultType+"' of state '"+u+"')")}function J(o,u){var p=o.$all?C(o.$all):[];delete o.$all;var h=Object.getOwnPropertyNames(o);u||(u=h[0]);for(var $=Object.create(null),y=0;y<h.length;y++){var g=h[y];$[g]=C(o[g]).concat(p)}for(var y=0;y<h.length;y++)for(var g=h[y],x=$[g],v=Object.create(null),d=0;d<x.length;d++){var w=x[d];if(!!w.include){var R=[d,1];if(w.include!==g&&!v[w.include]){v[w.include]=!0;var _=$[w.include];if(!_)throw new Error("Cannot include nonexistent state '"+w.include+"' (in state '"+g+"')");for(var E=0;E<_.length;E++){var N=_[E];x.indexOf(N)===-1&&R.push(N)}}x.splice.apply(x,R),d--}}for(var k=Object.create(null),y=0;y<h.length;y++){var g=h[y];k[g]=A($[g],!0)}for(var y=0;y<h.length;y++){for(var M=h[y],P=k[M],T=P.groups,d=0;d<T.length;d++)F(T[d],M,k);for(var L=Object.getOwnPropertyNames(P.fast),d=0;d<L.length;d++)F(P.fast[L[d]],M,k)}return new j(k,u)}function I(o){for(var u=Object.create(null),p=Object.create(null),h=Object.getOwnPropertyNames(o),$=0;$<h.length;$++){var y=h[$],g=o[y],x=Array.isArray(g)?g:[g];x.forEach(function(_){if((p[_.length]=p[_.length]||[]).push(_),typeof _!="string")throw new Error("keyword must be string (in keyword '"+y+"')");u[_]=y})}function v(_){return JSON.stringify(_)}var d="";d+=`switch (value.length) {
`;for(var w in p){var R=p[w];d+="case "+w+`:
`,d+=`switch (value) {
`,R.forEach(function(_){var E=u[_];d+="case "+v(_)+": return "+v(E)+`
`}),d+=`}
`}return d+=`}
`,Function("value",d)}var j=function(o,u){this.startState=u,this.states=o,this.buffer="",this.stack=[],this.reset()};j.prototype.reset=function(o,u){return this.buffer=o||"",this.index=0,this.line=u?u.line:1,this.col=u?u.col:1,this.queuedToken=u?u.queuedToken:null,this.queuedThrow=u?u.queuedThrow:null,this.setState(u?u.state:this.startState),this.stack=u&&u.stack?u.stack.slice():[],this},j.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},j.prototype.setState=function(o){if(!(!o||this.state===o)){this.state=o;var u=this.states[o];this.groups=u.groups,this.error=u.error,this.re=u.regexp,this.fast=u.fast}},j.prototype.popState=function(){this.setState(this.stack.pop())},j.prototype.pushState=function(o){this.stack.push(this.state),this.setState(o)};var z=r?function(o,u){return o.exec(u)}:function(o,u){var p=o.exec(u);return p[0].length===0?null:p};j.prototype._getGroup=function(o){for(var u=this.groups.length,p=0;p<u;p++)if(o[p+1]!==void 0)return this.groups[p];throw new Error("Cannot find token type for matched text")};function H(){return this.value}if(j.prototype.next=function(){var o=this.index;if(this.queuedGroup){var u=this._token(this.queuedGroup,this.queuedText,o);return this.queuedGroup=null,this.queuedText="",u}var p=this.buffer;if(o!==p.length){var g=this.fast[p.charCodeAt(o)];if(g)return this._token(g,p.charAt(o),o);var h=this.re;h.lastIndex=o;var $=z(h,p),y=this.error;if($==null)return this._token(y,p.slice(o,p.length),o);var g=this._getGroup($),x=$[0];return y.fallback&&$.index!==o?(this.queuedGroup=g,this.queuedText=x,this._token(y,p.slice(o,$.index),o)):this._token(g,x,o)}},j.prototype._token=function(o,u,p){var h=0;if(o.lineBreaks){var $=/\n/g,y=1;if(u===`
`)h=1;else for(;$.exec(u);)h++,y=$.lastIndex}var g={type:typeof o.type=="function"&&o.type(u)||o.defaultType,value:typeof o.value=="function"?o.value(u):u,text:u,toString:H,offset:p,lineBreaks:h,line:this.line,col:this.col},x=u.length;if(this.index+=x,this.line+=h,h!==0?this.col=x-y+1:this.col+=x,o.shouldThrow)throw new Error(this.formatError(g,"invalid syntax"));return o.pop?this.popState():o.push?this.pushState(o.push):o.next&&this.setState(o.next),g},typeof Symbol!="undefined"&&Symbol.iterator){var B=function(o){this.lexer=o};B.prototype.next=function(){var o=this.lexer.next();return{value:o,done:!o}},B.prototype[Symbol.iterator]=function(){return this},j.prototype[Symbol.iterator]=function(){return new B(this)}}return j.prototype.formatError=function(o,u){if(o==null)var p=this.buffer.slice(this.index),o={text:p,offset:this.index,lineBreaks:p.indexOf(`
`)===-1?0:1,line:this.line,col:this.col};var h=Math.max(0,o.offset-o.col+1),$=o.lineBreaks?o.text.indexOf(`
`):o.text.length,y=this.buffer.substring(h,o.offset+$);return u+=" at line "+o.line+" col "+o.col+`:

`,u+="  "+y+`
`,u+="  "+Array(o.col).join(" ")+"^",u},j.prototype.clone=function(){return new j(this.states,this.state)},j.prototype.has=function(o){return!0},{compile:G,states:J,error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:I}})})(moo),function(a){(function(){function e(s){return s[0]}function t(s){return s[0].value}function r(s){var f={};for(var m of s)f[m]={match:m,next:"main"};return f}var n=moo.exports,i=Object.assign({ws:{match:/\s+/,lineBreaks:!0,next:"main"},comment:/\#.*/,arrow:{match:/[=-]+\>/,next:"main"},js:{match:/\{\%(?:[^%]|\%[^}])*\%\}/,value:s=>s.slice(2,-2),lineBreaks:!0},word:{match:/[\w\?\+]+/,next:"afterWord"},string:{match:/"(?:[^\\"\n]|\\["\\/bfnrt]|\\u[a-fA-F0-9]{4})*"/,value:s=>JSON.parse(s),next:"main"},btstring:{match:/`[^`]*`/,value:s=>s.slice(1,-1),next:"main",lineBreaks:!0}},r([",","|","$","%","(",")",":?",":*",":+","@include","@builtin","@","]"])),l=n.states({main:Object.assign({},i,{charclass:{match:/\.|\[(?:\\.|[^\\\n])+?\]/,value:s=>new RegExp(s)}}),afterWord:Object.assign({},i,{"[":{match:"[",next:"main"}})});function c(s){for(var f=s.literal,m=[],S=0;S<f.length;S++){var O=f.charAt(S);O.toUpperCase()!==O||O.toLowerCase()!==O?m.push(new RegExp("["+O.toLowerCase()+O.toUpperCase()+"]")):m.push({literal:O})}return{subexpression:[{tokens:m,postprocess:function(C){return C.join("")}}]}}var b={lexer:l,rules:[{name:"final$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"final$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:function(s){return s[1]}},{name:"prog",symbols:["prod"],postprocess:function(s){return[s[0]]}},{name:"prog",symbols:["prod","ws","prog"],postprocess:function(s){return[s[0]].concat(s[2])}},{name:"prod",symbols:["word","_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{name:s[0],rules:s[4]}}},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{macro:s[0],args:s[3],exprs:s[9]}}},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:function(s){return{body:s[2]}}},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:function(s){return{config:s[1],value:s[3]}}},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!1}}},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!0}}},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"completeexpression",symbols:["expr"],postprocess:function(s){return{tokens:s[0]}}},{name:"completeexpression",symbols:["expr","_","js"],postprocess:function(s){return{tokens:s[0],postprocess:s[2]}}},{name:"expr_member",symbols:["word"],postprocess:e},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:function(s){return{mixin:s[1]}}},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:function(s){return{macrocall:s[0],args:s[3]}}},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:e},{name:"expr_member$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:function(s){return s[1]?c(s[0]):s[0]}},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:function(s){return{token:s[1]}}},{name:"expr_member",symbols:["charclass"],postprocess:e},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:function(s){return{subexpression:s[2]}}},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:function(s){return{ebnf:s[0],modifier:s[2]}}},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:t},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:t},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:t},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:function(s){return s[0].concat([s[2]])}},{name:"word",symbols:[l.has("word")?{type:"word"}:word],postprocess:t},{name:"string",symbols:[l.has("string")?{type:"string"}:string],postprocess:s=>({literal:s[0].value})},{name:"string",symbols:[l.has("btstring")?{type:"btstring"}:btstring],postprocess:s=>({literal:s[0].value})},{name:"charclass",symbols:[l.has("charclass")?{type:"charclass"}:charclass],postprocess:t},{name:"js",symbols:[l.has("js")?{type:"js"}:js],postprocess:t},{name:"_$ebnf$1",symbols:["ws"],postprocess:e},{name:"_$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[l.has("ws")?{type:"ws"}:ws]},{name:"ws$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"ws$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"ws",symbols:["ws$ebnf$1",l.has("comment")?{type:"comment"}:comment,"_"]}],start:"final"};a.exports=b})()}(nearley$1);var grammarWell={exports:{}};(function(a){(function(){function e(s){return s[0]}function t(s){return s[0].value}function r(s){const f={};for(let m of s)f[m]={match:m,next:"main"};return f}const n=moo.exports,i=Object.assign({ws:{match:/\s+/,lineBreaks:!0,next:"main"},comment:/\#.*/,arrow:{match:/[=-]+\>/,next:"main"},js:{match:/\{\%(?:[^%]|\%[^}])*\%\}/,value:s=>s.slice(2,-2),lineBreaks:!0},js2:{match:/\$\{(?:.*)\}/,value:s=>s.slice(2,-1),lineBreaks:!0},word:{match:/[\w\?\+]+/,next:"afterWord"},string:{match:/"(?:[^\\"\n]|\\["\\/bfnrt]|\\u[a-fA-F0-9]{4})*"/,value:s=>JSON.parse(s),next:"main"},btstring:{match:/`[^`]*`/,value:s=>s.slice(1,-1),next:"main",lineBreaks:!0}},r([",","|","$","%","(",")",":?",":*",":+","@include","@builtin","@","]"])),l=n.states({main:Object.assign({},i,{charclass:{match:/\.|\[(?:\\.|[^\\\n])+?\]/,value:s=>new RegExp(s)}}),afterWord:Object.assign({},i,r(["["]))});function c({literal:s}){const f=[];for(let m=0;m<s.length;m++){const S=s.charAt(m);S.toUpperCase()!==S||S.toLowerCase()!==S?f.push(new RegExp("["+S.toLowerCase()+S.toUpperCase()+"]")):f.push({literal:S})}return{subexpression:[{tokens:f,postprocess:m=>m.join("")}]}}var b={lexer:l,rules:[{name:"final$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"final$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"final",symbols:["_","prog","_","final$ebnf$1"],postprocess:function(s){return s[1]}},{name:"prog",symbols:["prod"],postprocess:function(s){return[s[0]]}},{name:"prog",symbols:["prod","ws","prog"],postprocess:function(s){return[s[0]].concat(s[2])}},{name:"prod",symbols:["word","_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{name:s[0],rules:s[4]}}},{name:"prod",symbols:["word",{literal:"["},"_","wordlist","_",{literal:"]"},"_",l.has("arrow")?{type:"arrow"}:arrow,"_","expression+"],postprocess:function(s){return{macro:s[0],args:s[3],exprs:s[9]}}},{name:"prod",symbols:[{literal:"@"},"_","js"],postprocess:function(s){return{body:s[2]}}},{name:"prod",symbols:[{literal:"@"},"word","ws","word"],postprocess:function(s){return{config:s[1],value:s[3]}}},{name:"prod",symbols:[{literal:"@include"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!1}}},{name:"prod",symbols:[{literal:"@builtin"},"_","string"],postprocess:function(s){return{include:s[2].literal,builtin:!0}}},{name:"expression+",symbols:["completeexpression"]},{name:"expression+",symbols:["expression+","_",{literal:"|"},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"expressionlist",symbols:["completeexpression"]},{name:"expressionlist",symbols:["expressionlist","_",{literal:","},"_","completeexpression"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"wordlist",symbols:["word"]},{name:"wordlist",symbols:["wordlist","_",{literal:","},"_","word"],postprocess:function(s){return s[0].concat([s[4]])}},{name:"completeexpression",symbols:["expr"],postprocess:function(s){return{tokens:s[0]}}},{name:"completeexpression",symbols:["expr","_","js"],postprocess:function(s){return{tokens:s[0],postprocess:s[2]}}},{name:"completeexpression",symbols:["expr","_","js2"],postprocess:function(s){return{tokens:s[0],transform:s[2]}}},{name:"expr_member",symbols:["word"],postprocess:e},{name:"expr_member",symbols:[{literal:"$"},"word"],postprocess:function(s){return{mixin:s[1]}}},{name:"expr_member",symbols:["word",{literal:"["},"_","expressionlist","_",{literal:"]"}],postprocess:function(s){return{macrocall:s[0],args:s[3]}}},{name:"expr_member$ebnf$1",symbols:[{literal:"i"}],postprocess:e},{name:"expr_member$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"expr_member",symbols:["string","expr_member$ebnf$1"],postprocess:function(s){return s[1]?c(s[0]):s[0]}},{name:"expr_member",symbols:[{literal:"%"},"word"],postprocess:function(s){return{token:s[1]}}},{name:"expr_member",symbols:["charclass"],postprocess:e},{name:"expr_member",symbols:[{literal:"("},"_","expression+","_",{literal:")"}],postprocess:function(s){return{subexpression:s[2]}}},{name:"expr_member",symbols:["expr_member","_","ebnf_modifier"],postprocess:function(s){return{ebnf:s[0],modifier:s[2]}}},{name:"ebnf_modifier",symbols:[{literal:":+"}],postprocess:t},{name:"ebnf_modifier",symbols:[{literal:":*"}],postprocess:t},{name:"ebnf_modifier",symbols:[{literal:":?"}],postprocess:t},{name:"expr",symbols:["expr_member"]},{name:"expr",symbols:["expr","ws","expr_member"],postprocess:function(s){return s[0].concat([s[2]])}},{name:"word",symbols:[l.has("word")?{type:"word"}:word],postprocess:t},{name:"string",symbols:[l.has("string")?{type:"string"}:string],postprocess:s=>({literal:s[0].value})},{name:"string",symbols:[l.has("btstring")?{type:"btstring"}:btstring],postprocess:s=>({literal:s[0].value})},{name:"charclass",symbols:[l.has("charclass")?{type:"charclass"}:charclass],postprocess:t},{name:"js",symbols:[l.has("js")?{type:"js"}:js],postprocess:t},{name:"js2",symbols:[l.has("js2")?{type:"js2"}:js2],postprocess:t},{name:"_$ebnf$1",symbols:["ws"],postprocess:e},{name:"_$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"_",symbols:["_$ebnf$1"]},{name:"ws",symbols:[l.has("ws")?{type:"ws"}:ws]},{name:"ws$ebnf$1",symbols:[l.has("ws")?{type:"ws"}:ws],postprocess:e},{name:"ws$ebnf$1",symbols:[],postprocess:function(s){return null}},{name:"ws",symbols:["ws$ebnf$1",l.has("comment")?{type:"comment"}:comment,"_"]}],start:"final"};a.exports=b})()})(grammarWell);var __awaiter$1=commonjsGlobal&&commonjsGlobal.__awaiter||function(a,e,t,r){function n(i){return i instanceof t?i:new t(function(l){l(i)})}return new(t||(t=Promise))(function(i,l){function c(f){try{s(r.next(f))}catch(m){l(m)}}function b(f){try{s(r.throw(f))}catch(m){l(m)}}function s(f){f.done?i(f.value):n(f.value).then(c,b)}s((r=r.apply(a,e||[])).next())})};Object.defineProperty(generator,"__esModule",{value:!0}),generator.Generator=void 0;const parser_1=parser$2,cow=require$$1,number=require$$2,postprocessor=require$$3,nearley=require$$4,string$1=require$$5,whitespace=require$$6,BuiltInRegistry={"cow.ne":cow,"number.ne":number,"postprocessor.ne":postprocessor,"nearley.ne":nearley,"string.ne":string$1,"whitespace.ne":whitespace};class Generator{constructor(e,t){this.config=e,this.compilerState=t,this.names=Object.create(null),this.neParser=new parser_1.Parser(nearley$1.exports),this.gwParser=new parser_1.Parser(grammarWell.exports),this.state={rules:[],body:[],customTokens:new Set,config:{},macros:{},start:"",version:"unknown"},this.state.version=e.version||this.state.version}import(e,t="grammar-well"){return __awaiter$1(this,void 0,void 0,function*(){if(typeof e=="string"){const r=yield this.mergeGrammarString(e,t);this.state.start=this.state.start||r.start;return}e=Array.isArray(e)?e:[e];for(const r of e)if("body"in r){if(this.config.noscript)continue;this.state.body.push(r.body)}else"include"in r?r.builtin?this.includeBuiltIn(r.include):yield this.includeGrammar(r.include):"macro"in r?this.state.macros[r.macro]={args:r.args,exprs:r.exprs}:"config"in r?this.state.config[r.config]=r.value:(this.buildRules(r.name,r.rules,{}),this.state.start=this.state.start||r.name)})}export(){return this.state}includeBuiltIn(e){if(e=e.toLowerCase(),!this.compilerState.alreadycompiled.has(e)){if(this.compilerState.alreadycompiled.add(e),!BuiltInRegistry[e])return;const{grammar:t}=BuiltInRegistry[e];for(const{symbols:r}of t.rules)for(let n=0;n<r.length;n++){const i=r[n];typeof i=="object"&&"regex"in i&&(r[n]=new RegExp(i.regex.source,i.regex.flags))}this.merge(BuiltInRegistry[e].grammar)}}includeGrammar(e){return __awaiter$1(this,void 0,void 0,function*(){const t=this.compilerState.resolver,r=t.path(e);this.compilerState.alreadycompiled.has(r)||(this.compilerState.alreadycompiled.add(r),yield this.mergeGrammarString(yield t.body(r),r.slice(-3)===".ne"?"nearley":"grammar-well"))})}mergeGrammarString(e,t="grammar-well"){return __awaiter$1(this,void 0,void 0,function*(){const r=new Generator(this.config,this.compilerState);t=="nearley"?yield r.import(this.neParser.run(e)):yield r.import(this.gwParser.run(e));const n=r.export();return this.merge(n),n})}merge(e){this.state.rules.push(...e.rules),this.state.body.push(...e.body),e.customTokens.forEach(t=>this.state.customTokens.add(t)),Object.assign(this.state.config,e.config),Object.assign(this.state.macros,e.macros)}uuid(e){return this.names[e]=(this.names[e]||0)+1,e+"$"+this.names[e]}buildRules(e,t,r){for(let n=0;n<t.length;n++){const i=this.buildRule(e,t[n],r);this.config.noscript&&(i.postprocess=null,i.transform=null),this.state.rules.push(i)}}buildRule(e,t,r){const n=[];for(let i=0;i<t.tokens.length;i++){const l=this.buildSymbol(e,t.tokens[i],r);l!==null&&n.push(l)}return{name:e,symbols:n,postprocess:t.postprocess,transform:t.transform}}buildSymbol(e,t,r){if(typeof t=="string")return t==="null"?null:t;if(t instanceof RegExp)return t;if("literal"in t)return t.literal.length?t.literal.length===1||this.state.config.lexer?t:this.buildStringToken(e,t,r):null;if("token"in t){if(this.state.config.lexer){const n=t.token;return this.state.customTokens.add(n),{token:`(${this.state.config.lexer}.has(${JSON.stringify(n)}) ? {type: ${JSON.stringify(n)}} : ${n})`}}return t}if("subexpression"in t)return this.buildSubExpressionToken(e,t,r);if("ebnf"in t)return this.buildEBNFToken(e,t,r);if("macrocall"in t)return this.buildMacroCallToken(e,t,r);if("mixin"in t){if(r[t.mixin])return this.buildSymbol(e,r[t.mixin],r);throw new Error("Unbound variable: "+t.mixin)}throw new Error("unrecognized token: "+JSON.stringify(t))}buildStringToken(e,t,r){const n=this.uuid(e+"$string");return this.buildRules(n,[{tokens:t.literal.split("").map(i=>({literal:i})),postprocess:{builtin:"joiner"}}],r),n}buildSubExpressionToken(e,t,r){const n=this.uuid(e+"$subexpression");return this.buildRules(n,t.subexpression,r),n}buildEBNFToken(e,t,r){const n=this.uuid(e+"$ebnf");let i={tokens:[]},l={tokens:[]};return t.modifier==":+"?(i.tokens=[t.ebnf],l.tokens=[n,t.ebnf],l.postprocess={builtin:"arrpush"}):t.modifier==":*"?(l.tokens=[n,t.ebnf],l.postprocess={builtin:"arrpush"}):t.modifier==":?"&&(i.tokens=[t.ebnf],i.postprocess={builtin:"id"},l.postprocess={builtin:"nuller"}),this.buildRules(n,[i,l],r),n}buildMacroCallToken(e,t,r){const n=this.uuid(e+"$macrocall"),i=this.state.macros[t.macrocall];if(!i)throw new Error("Unkown macro: "+t.macrocall);if(i.args.length!==t.args.length)throw new Error("Argument count mismatch.");const l={__proto__:r};for(let c=0;c<i.args.length;c++){const b=this.uuid(e+"$macrocall");l[i.args[c]]=b,this.buildRules(b,[t.args[c]],r)}return this.buildRules(n,i.exprs,l),n}}generator.Generator=Generator;var coffeescript={},util={};Object.defineProperty(util,"__esModule",{value:!0}),util.serializeRule=util.serializeSymbol=util.tabulateString=util.dedentFunc=util.serializeRules=void 0;function serializeRules(a,e,t=""){return`[
    `+a.map(function(r){return serializeRule(r,e)}).join(`,
    `)+`
`+t+"]"}util.serializeRules=serializeRules;function dedentFunc(a){var e=a.toString().split(/\n/);if(e.length===1)return[e[0].replace(/^\s+|\s+$/g,"")];for(var t=null,r=e.slice(1),n=0;n<r.length;n++){var i=/^\s*/.exec(r[n]);i&&i[0].length!==r[n].length&&(t===null||i[0].length<t.length)&&(t=i[0])}return t===null?e:e.map(function(c){return c.slice(0,t.length)===t?c.slice(t.length):c})}util.dedentFunc=dedentFunc;function tabulateString(a,e,t={}){var r;Array.isArray(a)?r=a:r=a.toString().split(`
`);var n=r.map(function(l,c){var b=!0;return c==0&&!t.indentFirst&&(b=!1),b?e+l:l}).join(`
`);return n}util.tabulateString=tabulateString;function serializeSymbol(a){return a instanceof RegExp?a.toString():a.token?a.token:JSON.stringify(a)}util.serializeSymbol=serializeSymbol;function serializeRule(a,e){var t="{";return t+='"name": '+JSON.stringify(a.name),t+=', "symbols": ['+a.symbols.map(serializeSymbol).join(", ")+"]",a.transform?t+=', "transform": '+tabulateString(dedentFunc(a.transform),"        ",{indentFirst:!1}):a.postprocess&&(a.postprocess.builtin&&(a.postprocess=e[a.postprocess.builtin]),t+=', "postprocess": '+tabulateString(dedentFunc(a.postprocess),"        ",{indentFirst:!1})),t+="}",t}util.serializeRule=serializeRule,Object.defineProperty(coffeescript,"__esModule",{value:!0}),coffeescript.CoffeescriptOutput=void 0;const util_1$1=util,CoffeescriptPostProcessors={joiner:"(d) -> d.join('')",arrconcat:"(d) -> [d[0]].concat(d[1])",arrpush:"(d) -> d[0].concat([d[1]])",nuller:"() -> null",id:"id"};function CoffeescriptOutput(a,e){return`# Generated automatically by nearley, version ${a.version}
# http://github.com/Hardmath123/nearley
do ->
  id = (d) -> d[0]
${(0,util_1$1.tabulateString)((0,util_1$1.dedentFunc)(a.body.join(`
`)),"  ")}
  grammar = {
    lexer: ${a.config.lexer},
    rules: ${(0,util_1$1.tabulateString)((0,util_1$1.serializeRules)(a.rules,CoffeescriptPostProcessors),"      ",{indentFirst:!1})},
    start: ${JSON.stringify(a.start)}
  }
  if typeof module != 'undefined' && typeof module.exports != 'undefined'
    module.exports = grammar;
  else
    window.${e} = grammar;
`}coffeescript.CoffeescriptOutput=CoffeescriptOutput;var javascript={};(function(a){Object.defineProperty(a,"__esModule",{value:!0}),a.ESMOutput=a.JavascriptOutput=a.JavascriptPostProcessors=void 0;const e=util;a.JavascriptPostProcessors={joiner:"function joiner(d) {return d.join('');}",arrconcat:"function arrconcat(d) {return [d[0]].concat(d[1]);}",arrpush:"function arrpush(d) {return d[0].concat([d[1]]);}",nuller:"function(d) {return null;}",id:"id"};function t(n,i){return`// Generated automatically by nearley, version ${n.version} 
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }
${n.body.join(`
`)}
var grammar = {
    lexer: ${n.config.lexer},
    rules: ${(0,e.serializeRules)(n.rules,a.JavascriptPostProcessors)},
    start: ${JSON.stringify(n.start)}
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.${i} = grammar;
}
})();
`}a.JavascriptOutput=t;function r(n,i){return`// Generated automatically by nearley, version ${n.version} 
// http://github.com/Hardmath123/nearley
function id(x) { return x[0]; }
${n.body.join(`
`)}
export default { 
    lexer: ${n.config.lexer},
    rules: ${(0,e.serializeRules)(n.rules,a.JavascriptPostProcessors)},
    start: ${JSON.stringify(n.start)}
};
`}a.ESMOutput=r})(javascript);var typescript={};Object.defineProperty(typescript,"__esModule",{value:!0}),typescript.TypescriptFormat=void 0;const util_1=util,TypescriptPostProcessors={joiner:"(d) => d.join('')",arrconcat:"(d) => [d[0]].concat(d[1])",arrpush:"(d) => d[0].concat([d[1]])",nuller:"() => null",id:"id"};function TypescriptFormat(a,e){return`// Generated automatically by nearley, version ${a.version}
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d: any[]): any { return d[0]; }
${Array.from(a.customTokens).map(function(t){return"declare var "+t+`: any;
`}).join("")}
${a.body.join(`
`)}

interface NearleyToken {
    value: any;
    [key: string]: any;
};

interface NearleyLexer {
    reset: (chunk: string, info: any) => void;
    next: () => NearleyToken | undefined;
    save: () => any;
    formatError: (token: never) => string;
    has: (tokenType: string) => boolean;
};

interface NearleyRule {
    name: string;
    symbols: NearleySymbol[];
    postprocess?: (d: any[], loc?: number, reject?: {}) => any;
};

type NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };

interface Grammar {
    lexer: NearleyLexer | undefined;
    rules: NearleyRule[];
    start: string;
};

const grammar: Grammar = {
    lexer: ${a.config.lexer},
    rules: ${(0,util_1.serializeRules)(a.rules,TypescriptPostProcessors,"  ")},
    start: ${JSON.stringify(a.start)},
};

export default grammar;
`}typescript.TypescriptFormat=TypescriptFormat;var json={};Object.defineProperty(json,"__esModule",{value:!0}),json.JSONFormatter=void 0;function JSONFormatter(a,e){const t=[];for(const r of a.rules)t.push(Object.assign(Object.assign({},r),{symbols:r.symbols.map(n=>n instanceof RegExp?{regex:{source:n.source,flags:n.flags}}:n)}));return JSON.stringify({grammar:Object.assign(Object.assign({},a),{rules:t,customTokens:Array.from(a.customTokens)}),exportName:e})}json.JSONFormatter=JSONFormatter;var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(a,e,t,r){function n(i){return i instanceof t?i:new t(function(l){l(i)})}return new(t||(t=Promise))(function(i,l){function c(f){try{s(r.next(f))}catch(m){l(m)}}function b(f){try{s(r.throw(f))}catch(m){l(m)}}function s(f){f.done?i(f.value):n(f.value).then(c,b)}s((r=r.apply(a,e||[])).next())})};Object.defineProperty(compiler,"__esModule",{value:!0}),compiler.Compiler=compiler.Compile=void 0;const import_resolver_1=importResolver,generator_1=generator,coffeescript_1=coffeescript,javascript_1=javascript,typescript_1=typescript,json_1=json,OutputFormats={_default:javascript_1.JavascriptOutput,object:(a,e)=>({grammar:a,exportName:e}),json:json_1.JSONFormatter,js:javascript_1.JavascriptOutput,javascript:javascript_1.JavascriptOutput,module:javascript_1.ESMOutput,esmodule:javascript_1.ESMOutput,cs:coffeescript_1.CoffeescriptOutput,coffee:coffeescript_1.CoffeescriptOutput,coffeescript:coffeescript_1.CoffeescriptOutput,ts:typescript_1.TypescriptFormat,typescript:typescript_1.TypescriptFormat};function Compile(a,e={}){return __awaiter(this,void 0,void 0,function*(){const t=new Compiler(e);return yield t.import(a,e.language),t.export(e.format)})}compiler.Compile=Compile;class Compiler{constructor(e={}){this.state={alreadycompiled:new Set,resolver:e.resolverInstance?e.resolverInstance:e.resolver?new e.resolver(e.basedir):new import_resolver_1.FileSystemResolver(e.basedir)},this.grammarBuilder=new generator_1.Generator(e,this.state)}import(e,t){return this.grammarBuilder.import(e,t)}export(e,t="grammar"){const r=this.grammarBuilder.export(),n=e||r.config.preprocessor||"_default";if(OutputFormats[n])return OutputFormats[n](r,t);throw new Error("No such preprocessor: "+n)}}compiler.Compiler=Compiler,function(a){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,n,i,l){l===void 0&&(l=i);var c=Object.getOwnPropertyDescriptor(n,i);(!c||("get"in c?!n.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return n[i]}}),Object.defineProperty(r,l,c)}:function(r,n,i,l){l===void 0&&(l=i),r[l]=n[i]}),t=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,n){for(var i in r)i!=="default"&&!Object.prototype.hasOwnProperty.call(n,i)&&e(n,r,i)};Object.defineProperty(a,"__esModule",{value:!0}),t(compiler,a),t(generator,a),t(importResolver,a),t(parser$2,a),t(basicLexer,a),t(legacyAdapter,a)}(build);let current={grammar:"",input:"",result:null};onmessage=async a=>{if(current.grammar==a.data.grammar&&current.input==a.data.input)return;current=a.data;const e=await TestGrammar(a.data.grammar,a.data.input);current.grammar==a.data.grammar&&current.input==a.data.input&&(current.result=e,postMessage(JSON.parse(JSON.stringify(current.result))))};async function TestGrammar(a,e){try{const t=await build.Compile(a,{resolverInstance:new BrowserImportResolver_1(self.location.origin)});if(current.grammar!=a||current.input!=current.input)return;const r=exports$1(t);return{result:new build.Parser(r).run(e)}}catch(t){return{error:t}}}function exports$1(source){let module={exports:""};return eval(source),module.exports}})();
